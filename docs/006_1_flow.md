# Flow-Centric Fee Model (Off-Chain Calculation MVP)

This document specifies an evolution of the Flow-Centric Fee Model, optimized for performance and user experience by moving the fee calculation off-chain. The on-chain program's role is reduced to a cheap, trustless verification step. This architecture provides transaction certainty for the user while keeping the on-chain hot path exceptionally efficient.

## Core Principle

The fee logic rewards trades that move the market toward a **health-adjusted equilibrium target**. This target is not simply the market's TWAP; it is the TWAP biased slightly upward as a function of the protocol's own floor price. This creates a positive feedback loop where a rising floor (a sign of protocol health) actively encourages price action that moves further away from that floor.

The user's client calculates the fee off-chain based on a recent snapshot of the market state. The on-chain program then simply verifies that the user's calculation was correct and that the market state has not significantly changed.

This creates a "social contract": the protocol agrees to honor a fee calculated against a slightly stale, but provably recent, state.

## The Model: Off-Chain Calculation, On-Chain Verification

The process is split into two distinct phases:

### 1. Off-Chain (Client-Side)

Before submitting a transaction, the user's client performs the following steps:
1.  **Read State:** It reads the required on-chain state variables just once: `market.current_tick`, `oracle.twap_tick`, the `signed_flow_ewma`, and the `pomm.floor_tick`.
2.  **Calculate Fee:** It performs the entire fee calculation locally. This involves first calculating the biased equilibrium target, then using that target in the fee formula from `006_flow.md`. This produces a single number, `calculated_fee_bps`.
3.  **Create Declaration:** It bundles the inputs and the result into a `TradeDeclaration`.
4.  **Submit Transaction:** The client sends the swap instruction including the `TradeDeclaration` as an argument.

### 2. On-Chain (Program-Side)

The `swap` instruction receives the `TradeDeclaration` from the client and performs a two-step verification before execution.

1.  **Staleness Check:** It first verifies that the state used by the client is not too old. It compares the `declared_state` from the user with the `actual_state` it reads from the chain.
2.  **Correctness Check:** If the state is fresh enough, it re-calculates the fee on-chain using the *exact same declared state variables* the client used (including the new biased target logic). It then asserts this matches the fee the client submitted.

If both checks pass, the swap is executed with the verified fee. If either check fails, the transaction reverts cleanly, protecting the user from an unexpected outcome.

## On-Chain Implementation

### The Biased Equilibrium Target

The core of the new logic is the calculation of the `t_equilibrium`, which replaces the pure TWAP in the displacement calculation.

```rust
// This logic is performed both off-chain by the client and on-chain for verification.
fn calculate_equilibrium_target(
    twap_tick: i32,
    floor_tick: i32,
    bias_bps: u16, // New policy parameter
) -> i32 {
    // Calculate how far the floor has risen from the absolute minimum tick.
    let effective_floor_height = floor_tick.saturating_sub(MIN_TICK);

    // The bias is a small percentage of this height.
    let bias_in_ticks = (effective_floor_height as i64 * bias_bps as i64) / 10000;

    // The new target is the TWAP plus the upward bias.
    twap_tick.saturating_add(bias_in_ticks as i32)
}
```

### The `TradeDeclaration`

The client passes this struct as an argument to the `swap` instruction. It now includes the `floor_tick`.

```rust
#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub struct TradeDeclaration {
    // The state the client used for calculation
    pub declared_tick: i32,
    pub declared_twap_tick: i32,
    pub declared_floor_tick: i32, // New field
    pub declared_flow_ewma: i64,

    // The resulting fee the client calculated
    pub calculated_fee_bps: u16,
}
```

### The Verification Flow

This logic would be at the beginning of the `swap` instruction handler.

```rust
fn swap(ctx: Context<Swap>, declaration: TradeDeclaration) -> Result<()> {
    // 1. Read actual, current state from accounts
    let actual_tick = ctx.accounts.market.current_tick;
    let actual_twap_tick = ctx.accounts.oracle.twap_tick;
    let actual_floor_tick = ctx.accounts.pomm.floor_tick;
    let actual_flow_ewma = ctx.accounts.market_dynamics.flow_ewma;

    // --- VERIFICATION ---

    // 2. Staleness Check: Ensure the client's state is fresh enough.
    const TICK_TOLERANCE: i32 = 2;
    const TWAP_TOLERANCE: i32 = 5;
    const FLOOR_TOLERANCE: i32 = 1; // Floor should change rarely
    const FLOW_TOLERANCE: i64 = 100_000; // Example value

    require!(
        actual_tick.abs_diff(declaration.declared_tick) <= TICK_TOLERANCE,
        FeelsError::StaleMarketState
    );
    require!(
        actual_twap_tick.abs_diff(declaration.declared_twap_tick) <= TWAP_TOLERANCE,
        FeelsError::StaleMarketState
    );
    require!(
        actual_floor_tick.abs_diff(declaration.declared_floor_tick) <= FLOOR_TOLERANCE,
        FeelsError::StaleMarketState
    );
    require!(
        actual_flow_ewma.abs_diff(declaration.declared_flow_ewma) <= FLOW_TOLERANCE,
        FeelsError::StaleMarketState
    );

    // 3. Correctness Check: Re-calculate the fee using the client's declared state.
    let expected_fee_bps = calculate_fee_on_chain(
        &declaration, // Pass the user's declared state
        &ctx.accounts.market.policy
    )?;

    // Verify the client did the math correctly on the state they declared.
    require!(
        expected_fee_bps == declaration.calculated_fee_bps,
        FeelsError::IncorrectFeeSubmitted
    );

    // --- EXECUTION ---

    // Verification passed. Proceed with the swap using the verified fee.
    execute_swap_logic(ctx, expected_fee_bps)?;

    // ...
    // Post-swap: update the flow_ewma using the ACTUAL results of the swap.
    update_flow_ewma(
        &mut ctx.accounts.market_dynamics,
        &swap_result
    )?;

    Ok(())
}
```

## Benefits of this Model

This architecture provides a superior combination of performance, security, and user experience.

1.  **High Performance:** The on-chain "hot path" (the swap itself) is extremely efficient. The verification logic is a handful of integer comparisons, which is computationally trivial.
2.  **Transaction Certainty:** Users know the *exact* fee they will pay before signing the transaction. The only other outcome is a clean revert if the market moves dramatically, which protects them from unforeseen costs.
3.  **Security and Robustness:** The model is trustless. The staleness and correctness checks prevent malicious users from gaming the system by submitting old state or miscalculated fees.
4.  **Incentive Alignment:** By biasing the equilibrium target with the floor price, the protocol actively rewards traders for price action that moves away from its own floor. This creates a powerful, self-reinforcing incentive for market health and price appreciation.