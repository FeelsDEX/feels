# Feels: Work-Based Dynamic Fee Model

This document specifies a work-efficient fee model for the Feels AMM that rewards genuine price discovery while maintaining system stability. The model treats trading as thermodynamic work, where efficient price movement is rewarded and value extraction is penalized.

## Core Principle

Markets require energy (volatility) to function and generate fees. We measure how efficiently traders convert their energy expenditure (slippage) into useful work (price discovery) and price fees accordingly.

## Thermodynamic Framework

### The Market as a Bounded Work Engine

In physics, not all work is useful. A key insight from thermodynamics is that work done far from equilibrium often dissipates as waste heat. Our market model captures this principle.

### The TWAP Potential Well

The market exists in a potential energy landscape where TWAP (time-weighted average price) represents the local equilibrium:

\[
U(x) = \frac{1}{2}k(x - x_{\text{TWAP}})^2
\]

Where:
- \(x\) = current price level (in ticks)
- \(x_{\text{TWAP}}\) = equilibrium price from 5-minute TWAP
- \(k\) = market "stiffness" (resistance to extreme moves)

### Useful vs Wasteful Work

Work efficiency must account for WHERE the work is performed:

\[
\eta_{\text{useful}} = \eta_{\text{raw}} \cdot \psi(\Delta x)
\]

Where \(\psi(\Delta x)\) is a coherence function:
\[
\psi(\Delta x) = \begin{cases}
1 & \text{if } |\Delta x| \leq \ell_c \\
\frac{\ell_c}{|\Delta x|} & \text{if } |\Delta x| > \ell_c
\end{cases}
\]

- \(\ell_c = 20\) ticks is the "coherence length"
- Within \(\ell_c\): Work contributes to genuine price discovery
- Beyond \(\ell_c\): Work increasingly dissipates as market distortion

### Physical Analogy: Damped Oscillator

The market behaves like a damped oscillator:
1. **Natural frequency**: Set by liquidity and volume
2. **Damping**: Provided by arbitrageurs and informed traders
3. **Forcing**: External information and sentiment

Attempts to push the system far from equilibrium face increasing resistance, similar to a spring's restoring force or a pendulum fighting gravity.

### Types of Market Participants (Revised)

1. **Coherent Engines**: Move price efficiently within the coherence length
   - Like a resonant driver at natural frequency
   - Maximum energy transfer to useful work
   
2. **Incoherent Engines**: Push price beyond coherence length
   - Like driving an oscillator off-resonance
   - Energy dissipates as waste heat (high fees)

3. **Parasitic Dampers**: Extract energy without adding information
   - Pure friction in the system
   - Necessary but should pay for the privilege

### Energy Balance with Bounded Work

\[
E_{\text{in}} = W_{\text{useful}} + W_{\text{waste}} + Q_{\text{dissipated}} + E_{\text{extracted}}
\]

Where:
- \(W_{\text{useful}}\): Price discovery within coherence length
- \(W_{\text{waste}}\): Extreme moves that revert (beyond \(\ell_c\))
- \(Q_{\text{dissipated}}\): Fees that sustain the system
- \(E_{\text{extracted}}\): Value leaving via arbitrage

Our fee model optimizes this balance by rewarding \(W_{\text{useful}}\) and penalizing \(W_{\text{waste}}\).

## Mathematical Model

### Per-Trade Work Efficiency

For each trade, calculate work efficiency with TWAP-based bounds:

\[
W = |\text{tick}_{\text{end}} - \text{tick}_{\text{start}}| \quad \text{// Absolute price movement}
\]
\[
S = \text{slippage}_{\text{bps}} \quad \text{// Execution shortfall in bps}
\]

**Key Innovation: Bounded Work Credit**

To prevent artificial price manipulation, we only credit work that keeps price within reasonable bounds:

\[
\text{twap\_distance} = |\text{tick}_{\text{end}} - \text{tick}_{\text{twap}}|
\]
\[
\text{reasonable\_range} = 20 \text{ ticks} \quad \text{// ~2\% from TWAP}
\]
\[
\text{work\_multiplier} = \begin{cases}
1.0 & \text{if } \text{twap\_distance} \leq \text{reasonable\_range} \\
\frac{\text{reasonable\_range}}{\text{twap\_distance}} & \text{otherwise}
\end{cases}
\]
\[
\eta = \frac{W \cdot \text{work\_multiplier} \cdot 100}{\max(S, 10)}
\]

This ensures:
- Full credit for moves within 2% of TWAP
- Diminishing credit for moves further out
- No incentive to push price to extremes

### Market Baseline

Track market's average work efficiency:

\[
\bar{\eta} = \text{EMA}(\eta_{\text{trade}}, \alpha) \quad \text{where } \alpha = \frac{1}{128} \text{ for stability}
\]

### Fee Function

Dynamic fee based on relative efficiency:

\[
r = \frac{\eta}{\max(\bar{\eta}, 1)} \quad \text{// Efficiency ratio}
\]

\[
\phi(r) = k \cdot \frac{2 - r}{1 + r} \quad \text{// Smooth, bounded modifier}
\]

\[
f = \text{clamp}(f_{\text{base}} + \phi(r), f_{\text{min}}, f_{\text{max}})
\]

Properties:
- When \(r = 1\): \(\phi = k/2\) (small surcharge)
- When \(r \to \infty\): \(\phi \to -k\) (maximum discount)
- When \(r \to 0\): \(\phi \to 2k\) (maximum surcharge)
- Continuous and monotonic

### Liquidity Momentum Adjustment

Simple three-state momentum tracker:

\[
\text{LM} \in \{-1, 0, 1\} \quad \text{// Draining, Stable, Growing}
\]

\[
\phi_{\text{lm}} = k_{\text{lm}} \cdot \text{LM} \cdot (1 - \text{trade\_size\_ratio})
\]

During liquidity drain (\(\text{LM} = -1\)), small trades get relief while large trades pay extra.

## Implementation

### State Structure

```rust
pub struct WorkDynamics {
    // Work efficiency tracking
    pub work_baseline: u32,      // Q16.16 fixed point
    pub last_update_slot: u64,   
    
    // Autopilot
    pub base_fee_bps: u8,
    pub flow_rate: u32,          // Q16.16
    
    // Liquidity momentum
    pub liquidity_1h_ago: u128,
    pub momentum_state: i8,      // -1, 0, 1
    
    // Constants
    pub k_work: u8,              // Work modifier strength (20 bps)
    pub k_momentum: u8,          // Momentum modifier (10 bps)
}
```

Total state: ~48 bytes

### Work Efficiency Calculation

```rust
fn calculate_work_efficiency(
    tick_start: i32,
    tick_end: i32,
    tick_twap: i32,
    slippage_bps: u16,
) -> u32 {
    let ticks_moved = (tick_end - tick_start).abs() as u32;
    let slippage_safe = max(slippage_bps, 10) as u32;
    
    // Calculate distance from TWAP
    let twap_distance = (tick_end - tick_twap).abs() as u32;
    const REASONABLE_RANGE: u32 = 20; // ~2% max distance
    
    // Apply work multiplier for moves beyond reasonable range
    let work_credit = if twap_distance <= REASONABLE_RANGE {
        ticks_moved << 16  // Full credit (Q16.16)
    } else {
        // Diminishing credit: reasonable_range / twap_distance
        (ticks_moved * REASONABLE_RANGE << 16) / twap_distance
    };
    
    // Return Q16.16 fixed point efficiency
    work_credit * 100 / slippage_safe
}
```

### Fee Calculation

```rust
fn calculate_fee(
    dynamics: &WorkDynamics,
    work_efficiency: u32,    // Q16.16
    trade_size_ratio: u8,    // 0-255 (0-100%)
) -> u16 {
    // Efficiency ratio in Q16.16
    let r = (work_efficiency << 16) / max(dynamics.work_baseline, 1 << 16);
    
    // Work fee modifier: (2 - r) / (1 + r) scaled by k
    let numerator = (2 << 16).saturating_sub(r);
    let denominator = (1 << 16) + r;
    let phi_work = (dynamics.k_work as u32 * numerator / denominator) >> 16;
    
    // Momentum adjustment
    let phi_momentum = match dynamics.momentum_state {
        -1 => {
            // Draining: relieve small, charge large
            let size_factor = 255 - trade_size_ratio;
            (dynamics.k_momentum as i16 * size_factor as i16) / 255
        },
        1 => -(dynamics.k_momentum as i16) / 2,  // Growing: small discount
        _ => 0,
    };
    
    // Combine
    let fee = dynamics.base_fee_bps as i16 + phi_work as i16 + phi_momentum;
    clamp(fee, 1, 200) as u16
}
```

### Integration Flow

```rust
fn process_swap(
    market: &mut Market,
    dynamics: &mut WorkDynamics,
    swap_params: SwapParams,
) -> Result<SwapResult> {
    // 1. Record starting state
    let tick_start = market.current_tick;
    
    // 2. Execute swap with dynamic fee
    let fee_estimate = estimate_fee(dynamics, swap_params);
    let result = execute_swap(market, swap_params, fee_estimate)?;
    
    // 3. Calculate actual work efficiency
    let work_eff = calculate_work_efficiency(
        tick_start,
        market.current_tick,
        result.slippage_bps,
    );
    
    // 4. Update baseline (every swap)
    update_work_baseline(dynamics, work_eff, result.size_ratio);
    
    // 5. Check epoch boundaries
    if is_new_epoch(current_slot, dynamics.last_update_slot) {
        update_momentum(dynamics, market.liquidity);
        update_autopilot(dynamics);
    }
    
    Ok(result)
}
```

## Robustness Features

### Anti-Gaming Measures

1. **Work is Costly**: Moving price requires real capital and risk
2. **Baseline Adaptation**: Gaming raises baseline, self-defeating
3. **Size Limits**: Large trades can't claim full discounts
4. **Bounded Modifiers**: Maximum Â±20bp adjustment
5. **TWAP Anchoring**: Work credit diminishes for extreme moves
   - Full credit within 20 ticks (~2%) of TWAP
   - Linear decay beyond that range
   - Prevents artificial price pumps/dumps for fee farming

### Edge Cases

```rust
// Minimum slippage floor prevents division issues
slippage_safe = max(slippage_bps, 10);

// Zero movement trades get standard fee
if ticks_moved == 0 { return base_fee; }

// Capped efficiency prevents extreme discounts
work_efficiency = min(work_efficiency, 100 << 16);
```

## Example Scenarios

### Informed Trader (Within Range)
- Moves price 10 ticks with 50 bps slippage
- Price stays within 20 ticks of TWAP
- Work efficiency: \(\eta = \frac{10 \cdot 1.0 \cdot 100}{50} = 20\)
- If baseline \(\bar{\eta} = 10\): \(r = 2 \to\) ~15% discount

### Memecoin Buyer (Extreme Move)
- Moves price 40 ticks with 500 bps slippage  
- Price now 40 ticks from TWAP (outside range)
- Work multiplier: \(\frac{20}{40} = 0.5\)
- Work efficiency: \(\eta = \frac{40 \cdot 0.5 \cdot 100}{500} = 4\)
- If baseline \(\bar{\eta} = 10\): \(r = 0.4 \to\) ~50% surcharge

### Price Manipulator (Attempted Gaming)
- Tries to push price 100 ticks with 200 bps slippage
- Price now 100 ticks from TWAP
- Work multiplier: \(\frac{20}{100} = 0.2\) (heavy penalty)
- Work efficiency: \(\eta = \frac{100 \cdot 0.2 \cdot 100}{200} = 10\)
- If baseline \(\bar{\eta} = 10\): \(r = 1 \to\) No discount earned!

## Benefits

1. **Thermodynamically Grounded**: Based on work/energy principles
2. **Incentive Aligned**: Rewards price discovery, penalizes extraction
3. **Volatility Positive**: More movement = more fees (if efficient)
4. **Simple**: ~48 bytes state, O(1) calculations
5. **Robust**: Costly to game, self-balancing

## Parameter Defaults

| Parameter | Value | Description |
|-----------|-------|-------------|
| `f_base` | 10 bps | Base fee rate |
| `k_work` | 20 bps | Work efficiency modifier |
| `k_momentum` | 10 bps | Momentum modifier |
| \(\alpha\) | 1/128 | Baseline EMA smoothing |
| `f_min` | 1 bp | Minimum fee |
| `f_max` | 200 bps | Maximum fee |

## Summary

This model treats the market as a thermodynamic engine where:
- Traders provide energy (through slippage)
- Efficient traders convert energy to work (price discovery) 
- Fees extract heat to sustain the system
- Work efficiency determines fair pricing

The result is a self-organizing system that rewards genuine price discovery while maintaining stability through controlled dissipation.