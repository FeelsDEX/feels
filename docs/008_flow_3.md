# Feels: Simplified Open Flow Model

This document specifies a streamlined flow-centric fee model for the Feels AMM. We retain the core insight of treating the market as an open energy system but dramatically simplify the implementation for robustness and efficiency. The entire system operates autonomously on-chain with no external dependencies or keeper requirements.

## Core Concept

The market is an energy network where user flow adds energy and LPs provide channels. Dynamic fees act as adaptive impedance: they increase under inefficient flow patterns and decrease when the market operates smoothly. The system measures one global efficiency signal and prices each trade relative to this baseline.

## Thermodynamic Interpretation

### The Market as an Open Dissipative System

Traditional AMM models often assume markets seek equilibrium, but real markets are open systems with continuous energy flow. Our model embraces this reality:

1. **Energy Input**: Every trade adds energy to the system (information, price discovery, volume)
2. **Dissipation**: Fees extract energy, preventing runaway states and rewarding system maintainers
3. **Channels**: Liquidity providers create pathways for energy flow
4. **Impedance**: Dynamic fees regulate flow rate to maintain system health

### Key Metric: Efficiency Baseline (Ē)

The efficiency baseline Ē represents the market's "specific dissipation" - how much price discovery the market achieves per unit of economic energy spent:

\[
\bar{E} = \text{average}(\text{execution\_shortfall\_in\_bps})
\]

#### Physical Analogy
- **High Ē** (>100 bps): Like a resistive circuit - lots of energy lost as "heat" (slippage)
- **Low Ē** (<30 bps): Like a superconductive state - energy flows with minimal loss
- **Target Ē** (30-50 bps): Optimal dissipation that sustains the system

#### What Ē Tells Us
- **Ē rising**: Market becoming less efficient, possibly due to:
  - Reduced liquidity depth
  - Increased volatility
  - Arbitrageur extraction
- **Ē falling**: Market becoming more efficient via:
  - Improved liquidity provision
  - Tighter spreads
  - Better price discovery

### Energy Conservation Principle

In our model, fees serve as the dissipation mechanism that prevents perpetual motion:

\[
E_{\text{in}} \text{ (trades)} = E_{\text{out}} \text{ (price discovery)} + E_{\text{dissipated}} \text{ (fees)}
\]

The dynamic fee adjustment ensures optimal dissipation:
- **Too little dissipation**: Market becomes unstable (manipulation, excess volatility)
- **Too much dissipation**: Market freezes (no trading, no price discovery)
- **Just right**: Sustainable flow that rewards all participants

### Practical Implications

1. **Self-Organization**: The market naturally finds efficient states without central planning
2. **Robustness**: System resists both manipulation and stagnation
3. **Fairness**: Inefficient trades subsidize efficient ones
4. **Sustainability**: Continuous fee flow maintains system infrastructure

## Design Principles

1. **Minimal state**: Track only essential signals
2. **Single-pass execution**: No duplicate simulations
3. **Bounded complexity**: O(1) operations with simple integer math
4. **Fail-safe defaults**: System degrades gracefully to base fees

## Global Efficiency Signal

We maintain a single efficiency baseline Ē through an exponentially-weighted moving average of realized execution quality:

### Efficiency Measurement

For each swap, compute realized shortfall as a fraction of ideal execution:
- **0→1**: \(s = \left|1 - \frac{\text{actual\_out}_1}{\text{in}_0 \times \text{start\_price}}\right|\)
- **1→0**: \(s = \left|1 - \frac{\text{actual\_out}_0}{\text{in}_1 / \text{start\_price}}\right|\)

Convert to basis points: \(E_{\text{obs}} = \text{clamp}(s \times 10{,}000, 10, 1000)\)

### Baseline Update

Update the global baseline using size-weighted averaging:
\[
\text{weight} = \min\left(\frac{\text{trade\_size}}{\text{market\_liquidity}}, 0.1\right)
\]
\[
\bar{E} = \bar{E} + \alpha \times \text{weight} \times (E_{\text{obs}} - \bar{E})
\]

Where:
- \(\alpha = \frac{1}{64}\): Learning rate
- \(\text{weight}\): Capped at 0.1 to prevent single-trade dominance
- Trade size and liquidity in comparable units

## Dynamic Fee Calculation

Each swap's fee has two components:

### 1. Efficiency Component

Compare trade efficiency to baseline:
\[
r = \frac{\bar{E}}{\max(E_{\text{obs}}, 1)}
\]
\[
\phi_{\text{eff}} = k_{\text{eff}} \times \frac{1 - r}{1 + |1 - r|}
\]

Properties:
- When \(r < 1\) (inefficient): positive surcharge up to \(+k_{\text{eff}}\)
- When \(r > 1\) (efficient): negative discount down to \(-k_{\text{eff}}\)
- Smooth, bounded transition around \(r = 1\)

### 2. Final Fee

\[
\text{fee\_bps} = \text{clamp}(f_{\text{base}} + \phi_{\text{eff}}, f_{\text{min}}, f_{\text{max}})
\]

## Simple Autopilot

A minimal controller adjusts the base fee to maintain healthy flow patterns.

### Thermodynamic Role

The autopilot acts as a thermostat, maintaining optimal "temperature" (flow rate) in the system:
- **Flow rate** = Energy flux through the market
- **Base fee** = Baseline impedance
- **Target flow** = Optimal operating temperature

When flow exceeds target, impedance increases to prevent overheating. When flow drops, impedance decreases to maintain activity.

### Flow Measurement

Track normalized flow intensity:
\[
\text{flow\_rate} = \frac{\text{volume\_1h}}{\max(\text{liquidity}, L_{\text{min}})}
\]
\[
F = \text{EMA}(\text{flow\_rate}, \alpha_{\text{flow}}) \quad \text{where } \alpha_{\text{flow}} = \frac{1}{256}
\]

### Control Logic

Every epoch (1 hour), evaluate and adjust:

\[
\begin{cases}
f_{\text{base}} = \min(f_{\text{base}} + 1, f_{\text{max\_base}}) & \text{if } F > F_{\text{target}} \times (1 + \delta) \\
f_{\text{base}} = \max(f_{\text{base}} - 1, f_{\text{min\_base}}) & \text{if } F < F_{\text{target}} \times (1 - \delta) \\
\text{no change} & \text{otherwise (within deadband)}
\end{cases}
\]

### Stability Features

1. **Cooldown**: Wait at least 2 epochs between adjustments
2. **Step limit**: ±1 bp per adjustment
3. **Deadband**: \(\delta = 0.2\) (20% tolerance)
4. **Bounds**: \(f_{\text{base}} \in [3, 30]\) bps

## Implementation Details

### State Requirements

```rust
pub struct MarketDynamics {
    // Efficiency tracking
    pub e_bar_bps: u16,              // Global efficiency baseline
    pub last_update_slot: u64,       // For epoch tracking
    
    // Autopilot state
    pub f_base_bps: u8,              // Current base fee
    pub flow_ema: u64,              // Flow rate EMA (Q32)
    pub volume_1h: u64,              // Rolling hour volume
    pub last_adjustment_epoch: u64,   // Cooldown tracking
    
    // Constants (or in Policy)
    pub f_min: u8,                   // 1 bp
    pub f_max: u16,                  // 100 bps
    pub k_eff: u8,                   // 20 bps
    pub f_target: u32,               // Target flow rate
}
```

### Swap Processing

```rust
fn calculate_dynamic_fee(
    market: &Market,
    dynamics: &MarketDynamics,
    swap_result: &SwapResult,
) -> u16 {
    // 1. Compute efficiency
    let e_obs = compute_shortfall_bps(swap_result);
    
    // 2. Calculate fee adjustment
    let r = (dynamics.e_bar_bps as u32 * 100) 
          / max(e_obs as u32, 1);
          
    let phi_eff = if r < 100 {
        // Inefficient: surcharge
        let penalty = (100 - r) * dynamics.k_eff / 100;
        min(penalty, dynamics.k_eff)
    } else {
        // Efficient: discount
        let discount = (r - 100) * dynamics.k_eff / 200;
        -(min(discount, dynamics.k_eff/2) as i16)
    };
    
    // 3. Final fee
    let fee = dynamics.f_base_bps as i16 + phi_eff;
    clamp(fee, dynamics.f_min as i16, dynamics.f_max as i16) as u16
}
```

### Autonomous Updates

All updates happen automatically during swap execution:

```rust
fn process_swap(
    market: &mut Market,
    dynamics: &mut MarketDynamics,
    swap_params: SwapParams,
) -> Result<SwapResult> {
    // 1. Execute swap with current fee
    let fee_bps = calculate_dynamic_fee(market, dynamics, &swap_result);
    let swap_result = execute_swap(market, swap_params, fee_bps)?;
    
    // 2. Update efficiency baseline (every swap)
    update_efficiency_baseline(dynamics, &swap_result);
    
    // 3. Update volume tracking
    dynamics.volume_1h = update_rolling_volume(dynamics.volume_1h, 
                                              swap_result.volume);
    
    // 4. Check epoch boundary and update autopilot
    if is_new_epoch(current_slot, dynamics.last_update_slot) {
        update_autopilot_internal(dynamics, market.liquidity);
        dynamics.last_update_slot = current_slot;
    }
    
    // 5. Update POMM if present (lazy check)
    let stressed = if let Some(pomm_state) = get_pomm_state_mut() {
        update_pomm(pomm_state, market, oracle_state, dynamics, 
                   current_slot, current_timestamp)
    } else {
        false
    };
    
    // 6. Distribute fees based on market conditions
    let distribution = FeeDistribution::calculate(stressed);
    distribute_fees(swap_result.fees_collected, &distribution)?;
    
    Ok(swap_result)
}

fn update_autopilot_internal(
    dynamics: &mut MarketDynamics,
    liquidity: u128,
) {
    // Check cooldown (2 epochs)
    if dynamics.last_update_slot - dynamics.last_adjustment_epoch 
       < 2 * EPOCH_SLOTS {
        return;
    }
    
    // Update flow EMA
    let current_flow = (dynamics.volume_1h as u128 * 100) / liquidity;
    dynamics.flow_ema = (dynamics.flow_ema * 255 + current_flow as u64) / 256;
    
    // Adjust base fee if outside deadband
    let f_ratio = (dynamics.flow_ema * 100) / dynamics.f_target;
    
    if f_ratio > 120 {  // > 1.2x target
        dynamics.f_base_bps = min(dynamics.f_base_bps + 1, 30);
        dynamics.last_adjustment_epoch = dynamics.last_update_slot;
    } else if f_ratio < 80 {  // < 0.8x target
        dynamics.f_base_bps = max(dynamics.f_base_bps - 1, 3);
        dynamics.last_adjustment_epoch = dynamics.last_update_slot;
    }
}
```

## Warm-up Period

New pools start in a simplified mode:

1. **First 50 swaps**: Use base fee only (5 bps default)
2. **Initialize baseline**: Set Ē to 2× tick spacing in bps
3. **Enable dynamics**: After 50 swaps AND 30 minutes
4. **Enable autopilot**: After 200 swaps AND 2 hours
5. **POMM activation**: Floor position immediate, support position after warm-up

## Parameter Reference

| Parameter | Default | Range | Description |
|-----------|---------|-------|-------------|
| `f_base` | 5 bps | [3, 30] | Base fee rate |
| `f_min` | 1 bp | - | Absolute minimum fee |
| `f_max` | 100 bps | - | Absolute maximum fee |
| `k_eff` | 20 bps | [10, 40] | Efficiency modifier strength |
| \(\alpha\) | 1/64 | - | Efficiency learning rate |
| \(\alpha_{\text{flow}}\) | 1/256 | - | Flow EMA rate |
| \(\delta\) | 0.2 | [0.1, 0.3] | Autopilot deadband |
| `F_target` | Market-specific | - | Target flow rate |

## Fee Distribution

Swap fees are dynamically distributed between LPs, POMM, and protocol based on market conditions:

### Normal Market Conditions
Default fee split when market is healthy:
- **LPs**: 80% - Primary liquidity providers
- **POMM**: 15% - Builds protocol-owned reserves
- **Protocol**: 5% - Operational sustainability

### Stress Conditions
When market stress is detected (same indicators as support activation):
- **LPs**: 90% - Increased rewards for providing liquidity during stress
- **POMM**: 8% - Reduced but maintains reserve building
- **Protocol**: 2% - Minimal take during stress

### Implementation

```rust
pub struct FeeDistribution {
    pub lp_share_bps: u16,      // Basis points to LPs
    pub pomm_share_bps: u16,    // Basis points to POMM
    pub protocol_share_bps: u16, // Basis points to protocol
}

impl FeeDistribution {
    pub fn calculate(stressed: bool) -> Self {
        if stressed {
            Self {
                lp_share_bps: 9000,      // 90%
                pomm_share_bps: 800,     // 8%
                protocol_share_bps: 200,  // 2%
            }
        } else {
            Self {
                lp_share_bps: 8000,      // 80%
                pomm_share_bps: 1500,    // 15%
                protocol_share_bps: 500,  // 5%
            }
        }
    }
}

fn distribute_fees(
    total_fees: u64,
    distribution: &FeeDistribution,
    liquidity_shares: &LiquidityShares,
) -> Result<()> {
    let lp_amount = (total_fees * distribution.lp_share_bps as u64) / 10_000;
    let pomm_amount = (total_fees * distribution.pomm_share_bps as u64) / 10_000;
    let protocol_amount = total_fees - lp_amount - pomm_amount; // Remainder
    
    // Update fee growth for LPs
    update_lp_fee_growth(lp_amount, liquidity_shares)?;
    
    // Credit POMM reserves
    credit_pomm_reserves(pomm_amount)?;
    
    // Credit protocol treasury
    credit_protocol_treasury(protocol_amount)?;
    
    Ok(())
}
```

### Benefits of Dynamic Distribution

1. **LP Incentive Alignment**: Higher rewards during stress encourages LPs to stay
2. **Countercyclical**: Protocol takes less when market needs support
3. **Reserve Building**: POMM continuously accumulates during all conditions
4. **Fair Value**: Those taking risk during stress earn more

## Benefits of Simplification

1. **Reduced state**: ~64 bytes for dynamics + ~48 bytes for POMM
2. **Single pass**: No pro-forma simulation needed
3. **Predictable**: Clear logic with bounded behaviors
4. **Market-aware**: Support position adapts via TWAP
5. **Efficient**: Fits easily in Solana's constraints
6. **Aligned incentives**: Fee distribution rewards liquidity when needed most

## Protocol-Owned Market Making (POMM)

A minimal system to ensure baseline liquidity and establish a rising floor price.

### Design Goals

1. **Floor guarantee**: Maintain a hard floor that rises with protocol revenue
2. **Non-competitive**: Never compete with LPs for price discovery
3. **Simple mechanics**: O(1) operations per swap
4. **Capital efficient**: Use protocol fees effectively

### Floor Price Definition

The floor price is deterministic:
\[
\text{floor\_price} = \frac{\text{total\_reserve\_value}}{\text{circulating\_supply}}
\]

Where:
- `total_reserve_value`: Protocol treasury backing
- `circulating_supply`: Total tokens that could be sold

### POMM Positions

The protocol maintains exactly two position types:

#### 1. Floor Position
- **Purpose**: Hard backstop to guarantee minimum price
- **Placement**: Single tick at \(\text{floor\_tick} = \text{tick}(\text{floor\_price} \times 0.995)\)
- **Size**: 95-100% of available POMM reserves
- **Movement**: Only moves up, never down (ratchet mechanism)

#### 2. Support Position (Stress-Activated)
- **Purpose**: Adaptive support level during market stress
- **Placement**: Midpoint between floor and 5-minute TWAP
  \[
  \text{support\_tick} = \frac{\text{floor\_tick} + \text{twap\_tick}}{2}
  \]
  Bounded to stay 2-10 ticks above floor
- **Size**: Max 5% of POMM reserves (borrowed from floor)
- **Activation**: Only when efficiency signals indicate stress

### Ratchet Mechanism

The floor ratchets up when ALL conditions are met:
1. Current price is comfortably above floor (≥5 ticks)
2. Accumulated fees exceed threshold (≥1% of POMM liquidity)
3. Time since last ratchet ≥ 1 epoch
4. No recent stress signals

When ratcheting:
- Move floor up by exactly 1 tick
- Reallocate liquidity in bounded chunks
- Never move more than 1% of liquidity per swap

### Stress Detection

Simple stress indicators:
- Efficiency baseline Ē > 100 bps (high execution shortfall)
- Price within 3 ticks of floor
- Rapid price decline (TWAP significantly above spot)

During stress:
- Activate support position at midpoint
- Pause floor ratcheting
- Deactivate after 1 epoch of calm

### Implementation

```rust
pub struct POMMState {
    // Floor management
    pub floor_tick_current: i32,
    pub floor_tick_target: i32,
    pub last_ratchet_slot: u64,
    
    // Support state  
    pub support_active: bool,
    pub support_tick: i32,
    pub stress_detected_slot: u64,
    
    // Metrics
    pub accumulated_fees: u64,
    pub last_reallocation_slot: u64,
}

fn update_pomm(
    pomm: &mut POMMState,
    market: &Market,
    oracle: &OracleState,
    dynamics: &MarketDynamics,
    current_slot: u64,
    current_timestamp: i64,
) {
    // Update floor target based on reserves
    let new_floor_price = calculate_floor_price();
    pomm.floor_tick_target = price_to_tick(new_floor_price * 0.995);
    
    // Check ratchet conditions
    if can_ratchet(pomm, market, current_slot) {
        pomm.floor_tick_current = min(
            pomm.floor_tick_current + 1,
            pomm.floor_tick_target
        );
        pomm.last_ratchet_slot = current_slot;
    }
    
    // Get TWAP for support positioning
    let twap_tick = oracle.get_twap_tick(current_timestamp, 300)?;
    
    // Stress detection
    let stressed = dynamics.e_bar_bps > 100 || 
                  market.current_tick - pomm.floor_tick_current < 3 ||
                  twap_tick - market.current_tick > 5; // TWAP significantly above spot
                  
    if stressed && !pomm.support_active {
        // Calculate support position
        let midpoint = (pomm.floor_tick_current + twap_tick) / 2;
        pomm.support_tick = midpoint
            .max(pomm.floor_tick_current + 2)  // Min 2 ticks above floor
            .min(pomm.floor_tick_current + 10) // Max 10 ticks above floor
            .min(twap_tick - 1);               // Stay below TWAP
            
        pomm.support_active = true;
        pomm.stress_detected_slot = current_slot;
    } else if !stressed && pomm.support_active &&
              current_slot - pomm.stress_detected_slot > EPOCH_SLOTS {
        pomm.support_active = false;
    }
}
```

### Reallocation Strategy

Per-swap liquidity moves are strictly bounded:
- Max 0.01% of position per swap
- Prioritize floor position integrity
- Use remaining account space efficiently

### Fully Autonomous Operation

All POMM updates happen automatically during swaps - no keepers required:

1. **During each swap**:
   - Check if floor needs ratcheting (O(1) check)
   - Update stress indicators
   - Move up to 0.01% of liquidity if needed
   
2. **Lazy updates**:
   - Floor price recalculation only when needed
   - Cushion activation/deactivation automatic
   - All state transitions deterministic

3. **No external dependencies**:
   - No price oracles needed
   - No keeper bots required  
   - No governance for routine operations

The system is designed to be fully self-operating, with all maintenance happening as a side effect of normal trading activity.

## Future Extensions

Once proven stable, consider adding:
1. **Liquidity momentum**: Small adjustment based on LP changes
2. **Volatility gating**: Wider bounds during high volatility
3. **Cross-market learning**: Share efficiency signals

The key is to prove each component works in isolation before combining them.