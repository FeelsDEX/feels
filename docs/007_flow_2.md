# Feels: Open Dissipative Flow Model

This document specifies a flow‑centric, open‑system fee model for the Feels AMM. The market is modelled as an energy network that must sustain healthy inflows and controlled dissipation, rather than a closed system seeking equilibrium. We track two global signals and then price each trade by its deviation from those baselines. The result is simple, bounded, and robust: it penalizes inefficient or spurious flow and rewards real price discovery. The system has no oracles, does not track user identities, and requires no off‑chain computation.

## A Physics Analogy to Build Intuition

Think of the market as an energy network. User flow adds energy, and LPs provide the channels for it to move. Dynamic fees are the circuit's impedance: they regulate current so throughput stays healthy.

We measure two "macroscopic" metrics that yield robust system information:
1. A global baseline for how much "price discovery" the market is currently achieving per unit of spend.
2. A global momentum signal for whether liquidity is charging (growing) or discharging (shrinking).

The floor price is a storage capacitor that fees steadily charge, raising the minimum executable level over time.

In thermodynamic terms, Ē (price discovery per unit spend) is like specific dissipation, the potential drop per unit flow.

Liquidity momentum is like the capacitor charge rate dQ/dt: positive when depth grows and negative when it drains. Our aim is to keep the market tradeable, steadily raise the floor, and damp sharp shocks without micromanaging normal volatility.

Local pricing then becomes congestion pricing: trades that perform worse than the baseline pay up, those that perform real work get a discount. If liquidity momentum is negative, fees ease for typical sizes (to prevent a death spiral) while large trades bear extra impedance to preserve remaining depth.

## Properties

The model exhibits four key characteristics:

1. **Self‑normalizing behavior**: \(r\) compares a trade to the current market baseline; there is no "correct price," only efficiency relative to peers.
2. **Robustness**: Clipping and saturation make the model stable under outliers and discourage gaming.
3. **Open‑system compliance**: \(LM\) detects charging/discharging, with fees adapting to keep the system healthy without turning off flow.
4. **Local and bounded**: The fee is a small, deterministic function of a few integers that runs fully on chain.

## Energy Interpretation

Let a surrogate potential be \(U(\delta) \propto g(\delta)\). The discrete resistance per step is
\[
\mathrm{d}W \;\propto\; \underbrace{\nabla U(\delta) \cdot \mathrm{d}x}_{\text{displacement}} \; + \; \underbrace{\lambda\, u\, s}_{\text{momentum/size gate}},
\]
which reduces to the bounded fee aggregator above (\(\phi_{\text{eff}}+\phi_{\text{lm}}\)). We do not seek equilibrium; we regulate flow to sustain long‑run power transfer while protecting the network from pathological regimes.

## Global Signals

We maintain two O(1) state variables via exponentially‑weighted moving averages (EWMA):

1) **Work efficiency baseline** \(\bar{E}\) from realized shortfall. Let \(p_0\) be the start price. Compute a fee‑neutral, pro‑forma execution shortfall \(s\) as a fraction of \(p_0\):
\[
\text{0→1:}\; s=\Bigl|1-\tfrac{\text{out1}_{\text{pf}}}{\max(\text{in0}\, p_0,\,1)}\Bigr|,\qquad
\text{1→0:}\; s=\Bigl|1-\tfrac{\text{out0}_{\text{pf}}}{\max(\text{in1}/\max(p_0,\varepsilon),\,1)}\Bigr|.
\]
Convert to basis points and apply a single hard clamp:
\[
E_{\text{obs}}\;=\; \operatorname{clamp}\bigl( s \cdot 10{,}000\ \text{bps},\; E_{\min},\; E_{\max} \bigr).
\]
Use a size‑weighted, per‑swap budget so small or pathological trades cannot move the baseline much. For weights use robust liquidity (not used in the shortfall):
\[
L_{\text{eff}} \;=\; \max\big( L_{\text{start}},\; L_{\text{floor}},\; L_{\text{slow\_EMA}} \big),\quad L_{\text{slow\_EMA}}^{+}=(1-\alpha_L)L_{\text{slow\_EMA}}+\alpha_L\,\operatorname{clip}(L_{\text{start}};0,L_{\max}).
\]
Let \(q\) be trade notional in token1 terms. Define \(f = q/\max(L_{\text{eff}},\varepsilon)\) and \(w = \operatorname{clamp}(f/f_\star, 0, 1)\). Maintain an epoch budget \(B\in[0,1]\) and reset it to 1 at epoch start. For each swap, consume \(u=\min(w, w_{\max}, B)\) and update
\[
\bar{E}^{+} \;=\; \operatorname{clamp}\Big( \bar{E} \,+\; \beta\, u\, (E_{\text{obs}} - \bar{E}),\; E_{\min}, E_{\max} \Big),\qquad B^{+}=B-u.
\]
This avoids end‑of‑epoch averaging and bounds per‑epoch movement by \(\beta\, B_{\max}\).

2) **Liquidity momentum** \(LM\). On a liquidity add or remove that changes dollarized capacity by \(\Delta L\) (clipped), update
\[
LM^{+} \;=\; LM \,+\; \gamma\,\big( \operatorname{clip}(\Delta L; L_{\min}, L_{\max}) - LM \big),\qquad 0<\gamma\le 1.
\]
Intuition: \(LM>0\) means depth grows; \(LM<0\) means it drains.

Both updates are O(1), integer‑friendly, and manipulation‑resistant via clipping and normalization.

## Per Swap Local Pricing

Given a swap we define an efficiency ratio using realized shortfall in bps:
\[
\textstyle r \;=\; \frac{\bar{E}}{\max(E_{\text{obs}},\,1)} \quad (\text{higher is more efficient}).
\]
A symmetric, saturating deviation term penalizes under‑performance and rewards over‑performance:
\[
\textstyle \phi_{\text{eff}}(r) \;=\; k_{\text{eff}}\, \frac{1 - r}{1 + r}, \qquad -k_{\text{eff}} < \phi_{\text{eff}} < k_{\text{eff}}.
\]
When \(r<1\) (inefficient; worse than baseline), \(\phi_{\text{eff}}>0\) is a surcharge; when \(r>1\) (efficient; better than baseline), \(\phi_{\text{eff}}<0\) is a discount.

### System Health Gating

We gate pricing adjustments by system health using momentum. Normalize \(u = \operatorname{clip}(|LM|/L_{\text{scale}}; 0,1)\) and size \(m = \operatorname{clip}(q/V_{\text{size}}; 0,1)\). Define a momentum term
\[
\phi_{\text{lm}} \;=\; \begin{cases}
-\,k_{\text{rebate}}\, u\,(1 - m), & LM \ge 0,\\[4pt]
\phantom{-}\,k_{\text{drain}}\, u\, m, & LM < 0.
\end{cases}
\]

Finally, the fee (in basis points) is the bounded sum
\[
\boxed{\quad f \;=\; \operatorname{clamp}\Big( f_{\min},\; f_{\text{base}} + \phi_{\text{eff}}(r) + \phi_{\text{lm}},\; f_{\max} \Big).\quad}
\]
All quantities are implemented in Q‑format integers; no floating point is used.

## Autonomous Self‑Calibration

A simple, bounded on‑chain controller can self‑tune a few policy levers from live signals to reduce hand‑tuning risk. It runs infrequently, applies tiny changes, and uses only price‑derived, normalization‑friendly data.

### Design Goals

The autopilot has several key objectives:

- Adjust `f_base` slowly using dimensionless, local signals
- No oracle dependency and cheap O(1) math per swap
- Prevent oscillations and gaming via deadbands, clamps, cooldowns, and minimum coverage requirements

### Signal Collection

Flow per liquidity serves as a congestion proxy. Let `p` be pool price (Q64), `q = in0*p + in1` the notional in token1 terms. Use robust liquidity `L_eff = max(L_start, L_floor, L_slow_EMA)` to avoid low‑L windows. Define `f = q / max(L_eff, ε)` (dimensionless) and maintain EMAs: `F_fast = EMA_fast(f)` and `F_slow = EMA_slow(f)`.

Strain/volatility provides optional guards through `ticks_crossed` per swap → `K_fast = EMA_fast(ticks_crossed)` or `V_fast = EMA_fast(|Δtick|)` as a short‑horizon volatility proxy.

These signals are robust across tokens because they normalize by liquidity and are clipped before use.

### Control Logic

The controller uses bounded logic with hysteresis. The congestion ratio is `C = clamp(F_fast / max(F_slow, ε), Cmin, Cmax)`. A deadband ensures we act only if `C > 1 + δ` or `C < 1 − δ`.

Epoch cadence evaluates every `N` swaps and after `≥T` slots, then adjusts by small steps: if congested, `f_base += Δb`; if slack, `f_base -= Δb`. Crisis override provides guardrails: if `K_fast` or `V_fast` exceeds high bands, raise to floors `f_base ≥ b_floor`. Optional damping slowly moves EMA gains toward a target `γ_target(C)` (more smoothing when congested).

All updates are clamped within `[min, max]` and quantized (integer bps) for predictability.

### Stability Mechanisms

The controller stays stable through two autonomous mechanisms derived from `α_slow` and a single base deadband `δ`:

1. **Dynamic deadband**: Maintains `δ_dyn` which equals `δ` at rest. On any parameter change, set `δ_dyn ← 2·δ` (temporary widening), then decay it each epoch toward `δ` using the same smoothing as `F_slow`: `δ_dyn ← max(δ, (1−α_slow)·δ_dyn + α_slow·δ)`. The decision rule uses `δ_dyn` instead of `δ` until it decays back.

2. **Auto‑cooldown**: Blocks further changes until `cooldown_epochs = max(1, ceil(1/(4·α_slow)))` have elapsed after any change, and enforces a slots floor (≥1024 slots). No reversals are allowed during cooldown.

The controller adjusts only `f_base`.

### Manipulation Protection

Several mechanisms resist gaming. Microtrade filtering ignores swaps with `f < f_min`. Coverage requirements apply updates only if the epoch contains ≥M counted swaps and spans ≥D distinct slots. Rate limits cap per‑epoch change (e.g., `±2` bps on `f_base`). Cooldown enforcement requires ≥T slots between parameter updates. Normalization makes manipulation costly: since `f = q / L_eff`, it's expensive to fake congestion without meaningful price/size; volatility/strain guards require real movement.

### State Requirements

The on‑chain state additions are compact. Policy knobs include `f_base_bps`, optional EMA gains, clamps, deadband, steps, floors, and cooldown parameters. Liquidity robustness tracks `L_floor`, `L_slow_EMA`, and its gain `α_L`. Telemetry EMAs maintain `F_fast`, `F_slow`, and either `K_fast` or `V_fast`. Epoch tracking records `last_update_slot`, `epoch_swap_count`, `epoch_slots_covered`. Optional advisory mode computes signals/decisions but doesn't apply changes (emit events only).

All arithmetic uses fixed‑point integers (e.g., Q64) and saturating math.

### Conservative Defaults

| Parameter | Value | Description |
|-----------|--------|-------------|
| `α_fast` | `1/128` | Fast EMA smoothing rate |
| `α_slow` | `1/2048` | Slow EMA smoothing rate |
| `α_L` | `1/2048` | Liquidity smoothing rate |
| `N` | `≥ 256` swaps | Minimum swaps per epoch |
| Epoch slots | `≥ 1024` slots | Minimum slots per epoch |
| `δ` | `0.1` | Deadband threshold |
| `f_base` | `[2, 100]` bps | Base fee clamps |
| `Δb` | `1` bps | Step size |
| Per-epoch cap | `±2` bps | Maximum change per epoch |
| `f_min` | Small value | Dust filter threshold |
| Guards | 95% EMA threshold | High bands for `K_fast`/`V_fast` |
| `L_floor` | Market-specific | Conservative liquidity floor |
| Cooldown | `≥ 512` slots | Minimum slots between updates |

### Pseudocode

```
on_swap_end(swap):
  # Compute normalized flow
  p = price_q64()
  q = swap.in0 * p + swap.in1
  L_eff = max(swap.liquidity_start, L_floor, L_slow_EMA)
  f = q / max(L_eff, ε)

  if f >= f_min:
    F_fast = (1-α_f) * F_fast + α_f * f
    F_slow = (1-α_s) * F_slow + α_s * f
    K_fast = (1-α_k) * K_fast + α_k * swap.ticks_crossed
    V_fast = (1-α_v) * V_fast + α_v * abs(swap.Δtick)

  epoch_swap_count += 1
  epoch_slots_covered += is_new_slot()

  if epoch_ready() and cooldown_over():
    C = clamp(F_fast / max(F_slow, ε), Cmin, Cmax)

    if C > 1 + δ:
      f_base_bps = min(f_base_bps + Δb, f_base_max)
    else if C < 1 - δ:
      f_base_bps = max(f_base_bps - Δb, f_base_min)

    if K_fast > K_hi or V_fast > V_hi:
      f_base_bps = max(f_base_bps, b_floor)

    emit AutopilotEvent { C, f_base_bps, F_fast, F_slow }
    reset_epoch_counters()
    last_update_slot = current_slot
```

### Validation Properties

The system guarantees several key properties:

- **Boundedness**: Parameters never leave clamps; per‑epoch caps are enforced
- **Monotone response**: With sustained `C > 1 + δ`, parameters drift upward; with `C < 1 − δ`, they drift downward
- **Stability**: With `C` oscillating inside the deadband around 1, parameters remain steady (no whipsaw)
- **Crisis handling**: `K_fast`/`V_fast` triggers raise floors promptly; recovery occurs only after signals cool sufficiently

## Warm‑Up (Cold Start)

A simple warm‑up avoids anchoring and anomolous fee pricing when a pool is new.

### Initialization Phase

Baseline setup sets baseline `Ē = E_init_bps` and momentum `LM = 0` at pool creation. Liquidity seeding initializes `L_slow_EMA = L_start` (first active liquidity) and sets a conservative `L_floor` per market. Component isolation keeps only base fee `f_base` active while disabling dynamic components (`φ_eff`, `φ_lm`) and autopilot.

### Coverage-Gated Activation

Activity tracking monitors `warmup_swaps` and `warmup_start_slot`. Dual gating enables dynamics only after both: `warmup_swaps ≥ N_warm` and `current_slot − warmup_start_slot ≥ S_warm`. Simple operation maintains fees = `f_base` (predictable early trades) and doesn't update `Ē` (hold fixed at `E_init_bps`) until conditions are met.

### Smooth Ramp (Optional)

Ramp initialization sets `ramp_start_slot = current_slot` and ramp length `S_ramp` on enable. Gradual scaling computes ramp factor `ρ = clamp((current_slot − ramp_start_slot)/S_ramp, 0, 1)` and scales dynamic parts: `k_eff_eff = ρ · k_eff`, `φ_lm_eff = ρ · φ_lm`. Autopilot gating keeps autopilot disabled until `ρ = 1` (or scales its step sizes by `ρ`).

### Baseline Management

During warm‑up the system keeps `Ē` constant at `E_init_bps` (skip updates) for simplicity. After enable it begins normal budgeted updates with `L_eff` weighting as specified above.

### Simple Defaults

| Parameter | Value | Description |
|-----------|--------|-------------|
| `E_init_bps` | `clamp(2 × tick_size_bps, 10, 40)` | Initial efficiency baseline |
| `tick_size_bps` | `round(10_000 × ((1.0001^tick_spacing) − 1))` | Tick size in basis points |
| `N_warm` | `32` swaps | Minimum swaps to exit warm-up |
| `S_warm` | `256` slots | Minimum slots to exit warm-up |
| `S_ramp` | `256` slots | Ramp duration |
| Base fee | Always active | Predictable fees during warm-up |
| Dynamic parts | Off until warm-up complete | `φ_eff`, `φ_lm` disabled |
| Autopilot | Off until ramp complete | No parameter adjustments |

### State Additions

| Field | Type | Description |
|-------|------|-------------|
| `warmup_enabled` | `bool` | Whether warm-up is active |
| `warmup_start_slot` | `u64` | Slot when warm-up started |
| `warmup_swaps` | `u32` | Number of swaps during warm-up |
| `N_warm` | `u32` | Required swaps to exit warm-up |
| `S_warm` | `u64` | Required slots to exit warm-up |
| `ramp_start_slot` | `u64` | Slot when ramp started |
| `S_ramp` | `u64` | Ramp duration in slots |
| `e_bar_bps` | `u32` | Efficiency baseline (Ē) |
| `lm` | `i64` | Liquidity momentum (0 at init) |
| `L_slow_EMA` | `u128` | Slow liquidity EMA |
| `L_floor` | `u128` | Liquidity floor |

### Integration Points

The swap path wiring follows a simple pattern:

```
on_swap(swap_params):
  if warmup_enabled:
    fee = f_base
    warmup_swaps += 1
    
    if warmup_swaps >= N_warm and current_slot - warmup_start_slot >= S_warm:
      warmup_enabled = false
      ramp_start_slot = current_slot
      
  else if current_slot - ramp_start_slot < S_ramp:
    # Ramping phase
    ρ = (current_slot - ramp_start_slot) / S_ramp
    φ_eff_scaled = ρ * φ_eff(r)
    φ_lm_scaled = ρ * φ_lm
    fee = clamp(f_min, f_base + φ_eff_scaled + φ_lm_scaled, f_max)
    # Keep autopilot disabled
    
  else:
    # Full dynamics
    fee = clamp(f_min, f_base + φ_eff(r) + φ_lm, f_max)
    # Enable autopilot
```

## Protocol‑Owned Liquidity Placement (Floor‑Only + Shock Absorber)

Keep the market maker minimal and aligned: steadily increase the floor price and provide a tiny, temporary bid "shock absorber" only under stress. No standing anchor/discovery ranges.

### Floor Price Management

- Floor definition sets floor price as `floor_price = reserve_assets / circulating_token_supply`.
- Conservative placement positions floor liquidity at `floor_tick_target = tick(floor_price × (1 − safety_margin))`. 
- A hard invariant ensures `Floor_Reserves ≥ Sellable_Tokens × floor_price × (1 + safety_buffer)`.

### Monotonic Floor Upkeep

Ratchet rules ensure the placed floor tick never moves down. Discrete steps ratchet up in small increments only when all conditions hold: market is comfortably above floor (`current_tick ≥ floor_tick_target + gap_ticks`), excess reserves over requirement ≥ `ratchet_threshold`, and ratchet cooldown elapsed (≥ 1 epoch since last move). Bounded changes limit each ratchet to at most `ratchet_step_ticks` and reallocate a bounded slice of liquidity per swap.

### Shock Absorber (Stress-Only)

A shock absorber ensures there is executable bid depth and dampens sharp dumps near the floor without competing with LPs. Shape creates a thin bid band `n_band_arrays` above the floor tick with budget share ≤ `absorber_max_share` of POMM budget. Signal monitoring maintains a short‑horizon EMA of shortfall `E_fast = EMA_fast(E_obs_bps)` for gating.

Stress engagement triggers when any of the following sustained signals indicate stress (with hysteresis and cooldown): `E_fast ≥ S_hi`, `C = F_fast/F_slow ≥ 1 + δ` and `LM < 0` for ≥ 1 epoch, or market within `proximity_ticks` of the floor tick. Stress disengagement occurs when signals normalize (e.g., median `E_obs_bps ≤ S_lo` and `C ≤ 1 + δ` for one epoch and price > proximity band). When off, the absorber budget returns to the floor.

### Automatic Execution

Input processing takes fresh fees (reserve token), `L_slow_EMA`, `F_fast/F_slow`, `V_fast`, `LM`, `current_tick`, and `floor_tick_target`. Single edit constraint applies exactly one edit per swap within strict caps `ΔL_cap_per_swap`.

The execution sequence follows three steps: First, enforce floor invariant by topping up floor with fresh fees; if still short, pull from absorber (if active). Second, if ratchet criteria are met and cooldown elapsed, move placed floor up by up to `ratchet_step_ticks` and shift a small slice of liquidity accordingly. Third, for shock absorber: if stress_on, ensure band is active and sized; if stress_off and absorber has funds, retract a slice back to floor.

Fallback handling records pending delta in state and emits a `POMMStepDeferred` event if required PDAs are not present as remaining accounts, then proceeds with the swap.

### State and Configuration

**PDA structure**:
- `POMM/[market]/floor` (always present)
- `POMM/[market]/absorber` (created on first engage)

**Policy parameters**:
- `safety_margin`, `safety_buffer`
- `gap_ticks`, `ratchet_threshold`, `ratchet_step_ticks`, `ratchet_cooldown_epoch`
- `ΔL_cap_per_swap`, `n_band_arrays`, `absorber_max_share`
- `S_hi/S_lo`, `proximity_ticks`, `cooldown_epoch`

**Runtime state**:
- `floor_tick_placed`, `last_ratchet_epoch`
- `absorber_active`, `last_absorber_toggle_epoch`

### Safe Defaults

Default values prioritize safety and simplicity:

**Safety margins**:
- `safety_margin = 0.5%`
- `safety_buffer = 5–10%`

**Ratchet parameters**:
- `gap_ticks = 1–2 arrays`
- `ratchet_threshold = 1–2%` excess
- `ratchet_step_ticks = 1 array`
- `ratchet_cooldown_epoch = 1`

**Absorber sizing**:
- `n_band_arrays = 1–2`
- `absorber_max_share = 3%` of POMM budget
- `ΔL_cap_per_swap = 0.5–1%` of POMM budget

**Stress thresholds**:
- Engage: `S_hi = 250 bps` on `E_fast` or `proximity_ticks ≤ 2` while `C ≥ 1+δ` and `LM < 0`
- Disengage: `S_lo = 120 bps` on `E_fast` and out of proximity for ≥1 epoch

### Operating Principles

The floor steadily increases as fees accumulate; ratchets are one‑way and gated to avoid churn. The absorber exists only under stress; otherwise, all budget sits at the floor, compounding the floor price. All actions are O(1) per swap, strictly bounded by per‑swap edit and ΔL caps.

## Practical Implementation

### Implementation Notes

**Shortfall computation**: Derives from realized average execution price versus the start price across the whole swap. Use the direction‑aware formulas above and keep shortfall independent of liquidity.

**Trade processing**: Compute trade notional \(q\) and robust liquidity \(L_{\text{eff}}\) once per swap. Derive \(w\), apply the budgeted update, then reset the budget at epoch rollover.

**Dust filtering**: Skip updates when \(f< f_{\min}\).

**Integer arithmetic**: Use fixed‑point integers with saturating clamps.

**Parameter tracking**: Maintain parameters in PolicyV1: \(f_{\text{base}}, f_{\min}, f_{\max}, k_{\text{eff}}, k_{\text{rebate}}, k_{\text{drain}}, f_{\star}, w_{\max}, B_{\max}, L_{\text{floor}}, \alpha_L, \beta, \gamma, E_{\min},E_{\max}\)

### Realized Shortfall Calculation: Order of Operations

To avoid circular dependencies (fee depends on s, which depends on outputs affected by the fee), base s on a fee‑neutral pro‑forma simulation and then apply the fee:

1. **Snapshot start state**: read `sqrt_price_start`, `current_tick`, derive `p0`, and record `L_start` before any simulation.
2. **Pro‑forma simulation** (no fee): run the swap engine with `fee_bps = 0` using the user's gross input to obtain a pro‑forma output `out_pf` and path stats (e.g., ticks crossed).
3. **Compute shortfall**: use `out_pf` with the direction‑aware formulas to get `s` and `E_obs_bps = clamp(s·10_000, E_min, E_max)`.
4. **Price the fee**: compute `r = Ē / max(E_obs_bps, 1)`, then `φ_eff(r)` and `φ_lm`, and set `fee_bps = clamp(f_min, f_base + φ_eff + φ_lm, f_max)`.
5. **Execute final swap**: run the engine once with `fee_bps`, using standard gross‑up/net‑in logic and updating fee growth, ticks, and events.
6. **Update baselines**: apply the budgeted Ē update using `E_obs_bps` from the pro‑forma simulation; update other EMAs from the observed path.

Single‑pass alternative: maintain a parallel "pro‑forma accumulator" inside the engine that computes `out_pf` by ignoring fees while the main path applies fees. This avoids a second full simulation at the cost of modest extra arithmetic per step. For MVP, the two‑pass flow is acceptable and simpler to reason about.

### Suggested Defaults (Gentle Start)

| Category | Parameter | Value | Description |
|----------|-----------|--------|-------------|
| **Base parameters** | \(f_{\text{base}}\) | 5 bps | Base fee rate |
| | \(f_{\min}\) | 2 bps | Minimum fee |
| | \(f_{\max}\) | 100 bps | Maximum fee |
| **Fee modifiers** | \(k_{\text{eff}}\) | 20 bps | Efficiency modifier |
| | \(k_{\text{rebate}}\) | 5 bps | Rebate modifier |
| | \(k_{\text{drain}}\) | 10–20 bps | Drain penalty modifier |
| **Update rates** | \(\beta\) | 1/64 | Efficiency baseline update rate |
| | \(\gamma\) | 1/64 | Liquidity momentum update rate |
| | \(f_{\star}\) | Median–80th percentile | Size weight threshold |
| **Liquidity** | \(\alpha_L\) | 1/2048 | Liquidity EMA rate |
| | \(L_{\text{floor}}\) | Market-specific | Conservative floor per market |
| **Budget controls** | \(B_{\max}\) | 1.0 | Maximum budget per epoch |
| | \(w_{\max}\) | 0.5 | Maximum weight per swap |
| **Dust filter** | \(f_{\min}\) | ~1e-6 | Threshold to ignore negligible trades |

### Manipulation Resistance

The system resists manipulation through several mechanisms:

- **Realized impact measurement**: Uses execution shortfall vs start price, reflecting non‑linear depth automatically
- **Robust liquidity weighting**: Employs \(L_{\text{eff}}=\max(L_{\text{start}},L_{\text{floor}},L_{\text{slow\_EMA}})\) to prevent low‑liquidity windows from amplifying influence
- **Budgeted updates**: Cap total baseline movement per epoch via \(B_{\max}\); per‑swap cap \(w_{\max}\) avoids single‑trade dominance
- **Bounded outcomes**: Ensure fee \(f\) always stays between \(f_{\min}\) and \(f_{\max}\); surcharges/discounts are limited by \(k_{\text{eff}}, k_{\text{rebate}}, k_{\text{drain}}\)

### Testing Strategy

The testing approach covers multiple levels:

- **Unit tests**: Verify monotonicity of \(\phi_{\text{eff}}\) in \(r\), symmetry at \(r=1\), saturation at bounds, and LM gating behavior
- **Engine tests**: Use identical‑size swaps with different realized shortfall to confirm inefficient trades pay more and efficient trades pay less
- **Integration tests**: Check that sustained one‑sided flow increases \(\bar{E}\) and triggers surcharges for churn, while LM<0 reduces fees for small trades but penalizes large drains

### Roadmap

Future enhancements include adding an inventory/skew term (small, capped) for further manipulation resistance under thin books. The system can extend the same pattern to time/leverage dimensions while keeping components independent to avoid cascade failures. Optional hysteresis on \(f\) could avoid oscillations at thresholds.