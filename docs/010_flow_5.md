# Floor‑Skewed AMM

**Purpose.** Define a solvency‑hard AMM with a structural upward skew. The design couples a piecewise‑linear fee controller (execution heat minus useful work) with a biased work anchor above the TWAP, a ratcheting floor funded by fees, and a tiny protocol‑owned market maker (PoMM) that defends the floor range. All math is integer/fixed‑point; no oracles; no identity.

---

## 0) Goals & Constraints

* **Simple**: O(1) per‑swap controller (beyond normal tick loop).
* **Robust**: Hard solvency via floor; anti‑ping‑pong; bounded fees.
* **Fully on‑chain**: No off‑chain keepers; deterministic ratchet.
* **Speculation stays interesting**: Trend pushes pay; precise discovery discounted.
* **No violent liquidation dynamics**: Soft circuit breaker via piecewise slope + caps.

---

## 1) Solvency Model (Two Buckets)

Track reserves and supply with explicit separation:

* **Protected reserves** $R_*$ — irrevocably backing the floor.
* **Buffer** $\tau$ — fees & PoMM PnL not yet committed to the floor.
* **Circulating supply** $S_{\text{circ}}$ — total minted minus *all* protocol‑owned tokens (including PoMM and protocol LP inventory).

### Floor Price (hard invariant)

$$
P_{\text{floor}} \;=\; \left\lfloor \frac{R_*}{S_{\text{circ}}} \right\rfloor
$$

* Redemptions settle **exactly** at $P_{\text{floor}}$ from $R_*$ (round down) → solvency is mechanical.
* Fees accrue into $\tau$. Only ratcheted amounts moved from $\tau\to R_*$ raise the floor.

### Haircuts & Liabilities (optional, conservative)

If $R_*$ spans multiple assets or yield tokens:

$$
R_* \;=\; \sum_i h_i\,V_i \, -\, \text{liabilities},\quad 0<h_i\le1
$$

Choose $h_i$ to cover depeg/vol risks; floor‑round all operations.

---

## 2) Price & Anchors

* **TWAP**: use your existing **geometric** TWAP; represent as a tick $\text{twap\_tick}$.
* **Floor tick**: $\text{tick}_* = \big\lfloor \log_{1.0001}(P_{\text{floor}}) \big\rfloor$ (or conservative mapping via sqrt‑price helpers).
* **Biased work anchor** (structural upward skew):

$$
R \;=\; \max\big(\text{twap\_tick},\, \text{tick}_* + \Delta\big)
$$

$\Delta$ is a small constant offset in ticks (e.g., 25–75). When the floor sits under price, work credit is biased **upward**; otherwise it reduces to TWAP.

*(Optional smooth bias: $R = \text{twap\_tick} + \lambda\,\max(0,\text{tick}_*+\Delta-\text{twap\_tick})$, small $\lambda\in[0,1]$.)*

---

## 3) Piecewise‑Linear Fee Controller

Per swap, let:

* $q$: absolute quote filled (quote token units).
* $\Delta t = |\text{end\_tick} - \text{start\_tick}|$.
* **Execution heat** $x = \dfrac{\Delta t}{\max(q,1)}$ (scale by a fixed $\text{Q\_PIVOT}$ to keep integers small).
* **Work efficiency** toward anchor $R$:

$$
 y = \frac{\max\big(0,\,|\text{start}-R| - |\text{end}-R|\big)}{\max(\Delta t,1)} \in [0,1]
$$

* **Slot penalty** $P_{\text{slot}}$: add $p_0$ bps if the trade direction matches the current slot’s signed net quote, else 0.

### Execution surcharge $F_{\text{exec}}(x)$

Two‑segment linear with knee $k_1$ and cap $k_2$, slopes $m_1<m_2$ (bps per unit $x$):

$$
F_{\text{exec}}(x)=
\begin{cases}
 m_1 x & 0\le x\le k_1\\
 m_1 k_1 + m_2(x-k_1) & k_1 < x\le k_2\\
 m_1 k_1 + m_2(k_2-k_1) & x>k_2\quad(\text{capped})
\end{cases}
$$

### Work credit $C_{\text{work}}(y, d_{\text{before}})$

Tapered linear credit with band $b$ (ticks), slope $c_1$, cap $c_{\max}$ (bps):

$$
\text{taper} = \min\!\Big(1,\; \frac{b}{\max(d_{\text{before}},1)}\Big),\quad d_{\text{before}}=|\text{start}-R|
$$

$$
C_{\text{work}} = \min(c_1 y,\, c_{\max})\cdot \text{taper}
$$

### Final fee (bps) and charge

$$
\phi_{\text{bps}} = \operatorname{clamp}\left( \text{BASE} + F_{\text{exec}}(x) - C_{\text{work}}(y,d_{\text{before}}) + P_{\text{slot}},\; \text{MIN},\, \text{MAX} \right)
$$

Fee in quote units: $\text{fee}_q = \left\lceil \phi_{\text{bps}}\, q / 10{,}000 \right\rceil$. Route $\text{fee}_q\to \tau$.

**Anti‑gaming:** splitting trades does not escape heat; moving away from $R$ yields no credit; far‑from‑anchor pushes get little credit due to taper; slot penalty adds short‑memory hysteresis.

---

## 4) Ratcheting the Floor (Deterministic)

Maintain a constant quantum **COST\_PER\_TICK** for moving the floor one tick (seed/move protocol floor liquidity). On any pool‑touching instruction:

1. If $\tau \ge \text{COST\_PER\_TICK}$: transfer that quantum from $\tau\to R_*$; increment $\text{tick}_*$ by $\text{TICK\_STEP}$; (re)place floor liquidity.
2. Loop while budget allows; O(1) each iteration; bounded by a small max per call.

This converts dissipated “heat” (fees) into **irreversible work** (higher floor).

---

## 5) Protocol‑Owned MM (PoMM) — Two Bands

**Funding:** PoMM spends only $\tau$ (budgeted). **Never** spends $R_*$.
**Inventory:** protocol‑owned tokens are **non‑circulating** (excluded from $S_{\text{circ}}$).

* **Lower Support (buy, large):** $[\,\text{tick}_*+\delta_L,\; \text{tick}_*+\delta_L+W_L\,]$, size $L$.

  * Fills: pay from $\tau$; **burn** acquired tokens (or hold as non‑circulating). Floor $\uparrow$ or unchanged, never down.
* **Upper Brake (sell, small):** $[\,R+\delta_U,\; R+\delta_U+W_U\,]$, size $U\ll L$.

  * Sells **only** inventory; proceeds → $\tau$.

**Upkeep rules (cheap):**

* On ratchet: shift both bands up by $\text{TICK\_STEP}$.
* On drift: if TWAP moves > $W_U/2$ above upper band center, recenter **upper** around new $R$.
* Keep ≤1 lower and ≤1 upper position live.

---

## 6) Redemption at Floor (Permissionless)

`redeem(s)` burns $s$ tokens; pays $s\cdot P_{\text{floor}}$ from $R_*$. Post‑state preserves or raises the floor:

$$
R_*' = R_* - s P_{\text{floor}},\quad S_{\text{circ}}' = S_{\text{circ}} - s,\quad \left\lfloor \frac{R_*'}{S_{\text{circ}}'} \right\rfloor \ge P_{\text{floor}}
$$

---

## 7) Thermodynamic Analogy (Intuition)

* The pool is an **open dissipative system** with local equilibrium (TWAP). Traders inject **effort** by spending quote to move the generalized coordinate (tick).
* **Execution surcharge** is viscous/turbulent **drag**: linear at low “velocity” (impact per unit spend), steeper past a knee (soft breaker).
* **Work credit** measures **energy captured**: if a push reduces free energy (moves price toward the anchor $R$), part of the input is useful work and is rebated (linearly, band‑tapered). Disorderly pushes get no rebate.
* **Fees → $\tau$ → ratchet**: dissipated heat accumulates in a reservoir; once thresholded, it performs **irreversible work** on the system (floor steps up), creating lasting structure. PoMM acts as a heat sink/baffle near the boundary.

---

## 8) Solana Implementation Guide (Efficient & Safe)

### Accounts (minimal)

* **Pool**: existing AMM state (ticks/bitmap/liquidity, sqrt\_price, fee growth).
* **Thermo** (PDA): `{ tick_floor, tau, cost_per_tick, floor_liq, delta_bias, q_pivot, params_hash }`.
* **Metrics** (PDA): `{ slot_id, slot_net_q, twap_tick, ewm_helpers(optional) }`.
* **PoMM** (PDA): `{ lower_pos, upper_pos, inventory_token_0cc, tau_budget_remaining }`.
* **Vaults**: base/quote token accounts for fees, floor seeding, and PoMM inventory.
* **Supply registry**: track `S_circ` (exclude protocol holdings, include burns/mints).

### Instructions

1. `swap(amount_in, sqrt_price_limit, ...)`

   * Execute tick loop; compute `q`, `Δt`, `start/end ticks`.
   * Update slot boundary & `slot_net_q`.
   * Load `twap_tick` (geometric; or EMA‑per‑slot update if you prefer).
   * Compute fee via controller; transfer quote fee → `tau`.
   * Try ratchet loop (bounded iterations).
2. `ratchet_floor()`

   * Purely spends `tau` to move `tick_floor`; idempotent.
3. `redeem(amount)`

   * Burn tokens; pay `amount * P_floor` from protected reserves.
4. `pomm_maintain()` (optional; cheap)

   * Enforce PoMM invariants; recenter upper band; reopen positions if thresholds met.
5. `configure(params)` (governed, hard‑bounded)

   * Only allows changes within safe ranges; write `params_hash` to Thermo.

### Math & Numerics

* **Fixed‑point**: Use `u128` with Q64.64 or Q32.32 for multipliers; keep $x,y$ pre‑scaled by `Q_PIVOT` and/or a power‑of‑two to enable shifts.
* **Tick math**: map price↔tick via standard helpers; store `ln_gamma = ln(1.0001)` as constant if needed for diagnostics only—controller uses ticks directly.
* **Rounding**: floor‑round all divisions affecting $P_{\text{floor}}$ and price→tick; ceil‑round fee charges.
* **Saturating ops**: use saturating add/sub; assert no underflow on `tau`/`R_*` updates.
* **Gas/compute**: controller is O(1); additional cost is small vs. the tick loop. PoMM maintenance is event‑driven and rare.

### Invariants to Assert On‑Chain

* `MIN_BPS ≤ φ ≤ MAX_BPS`; `tau ≥ 0`; `R_* ≥ 0`; `S_circ ≥ 0`.
* `PoMM` sells only from inventory; never places sell liquidity below `tick_floor`.
* `tau` spend per tx ≤ configured budget; ratchet loop max iterations per call.
* Post‑redeem floor inequality holds.

---

## 9) Parameters (sane defaults)

* Fees: `BASE=15` bps, `MIN=5`, `MAX=100`, `p0=8` bps.
* Exec: `k1=1.0`, `k2=4.0` (in ticks per pivot‑quote), slopes `m1=8`, `m2=20` bps/unit.
* Work: `c1=15` bps/unit, `c_max=25` bps, band `b=200` ticks (\~2%).
* Bias: `Δ=50` ticks; `TICK_STEP=1` (or your spacing); `Q_PIVOT` set to median quote size at deployment.
* Ratchet: choose `COST_PER_TICK` so a typical day of fees advances the floor a few ticks (story‑driven).
* PoMM: sizes `L:U = 3:1`, widths `W_L=120`, `W_U=80`, offsets `δ_L=10`, `δ_U=30`.

---

## 10) Reference Pseudocode (per‑swap core)

```
// after executing swap and knowing start_tick, end_tick, quote_filled
// 1) slot boundary
if slot != metrics.slot_id { metrics.slot_id = slot; metrics.slot_net_q = 0; }

let q      = abs(quote_filled);
let dticks = abs(end_tick - start_tick);

// 2) anchor R with upward bias
let tick_floor = thermo.tick_floor;
let R = max(twap_tick, tick_floor + DELTA_BIAS);

// 3) execution heat (pre-scale by Q_PIVOT to keep integers nice)
let x_num = dticks * Q_PIVOT;
let x     = x_num / max(q,1);

// two‑segment exec fee
let mut f_exec = m1 * min(x, k1);
if x > k1 { f_exec += m2 * min(x - k1, k2 - k1); }

// 4) work efficiency toward R
let d_before = abs(start_tick - R);
let d_after  = abs(end_tick   - R);
let closed   = d_before.saturating_sub(d_after); // 0 if widened
let y        = closed / max(dticks,1);
let taper    = min(1, BAND / max(d_before,1));   // integer taper
let c_work   = min(c1 * y, c_max) * taper;

// 5) slot penalty
let same_dir = (metrics.slot_net_q >= 0) == (quote_filled >= 0);
let p_slot   = if same_dir { P0 } else { 0 };

// 6) final fee
let phi_bps  = clamp(BASE + f_exec + p_slot - c_work, MIN, MAX);
let fee_q    = ceil_div(phi_bps * q, 10_000);

// route fees and update slot flow
thermo.tau += fee_q;          // saturating add
metrics.slot_net_q += quote_filled;

// 7) ratchet loop (bounded)
let mut steps = 0;
while thermo.tau >= COST_PER_TICK && steps < MAX_RATCHET_STEPS_PER_TX {
    thermo.tau -= COST_PER_TICK;
    thermo.tick_floor += TICK_STEP;
    place_or_shift_floor_liquidity(thermo.tick_floor, thermo.floor_liq);
    steps += 1;
}
```

---

## 11) Test Plan (must pass)

1. **Solvency invariance**: random mints/burns/redemptions → floor formula holds exactly; no underflow.
2. **Calm market**: small trades near TWAP → fees ≈ BASE; slow floor ascent.
3. **Impactful pushes**: large $\Delta t$ → exec surcharge increases piecewise; caps respected.
4. **Useful discovery**: reversion toward $R$ → fee reduced but not below MIN; away from $R$ → no credit.
5. **Ping‑pong**: alternating trades within slot → later trades pay $p_0$ extra.
6. **PoMM safety**: buys spend only $\tau$; sells inventory only; never places sell below floor.
7. **Ratchet determinism**: exact $\lfloor \tau/\text{COST\_PER\_TICK} \rfloor$ steps; no drift.

---

## 12) Initialization & Warmup (Oracleless)

**Objective.** Boot the fee system with constant-time rules, avoid noisy anchors at genesis, and phase in the “work credit” only when enough on-chain evidence accumulates. No oracles; all counters are local.

### State additions

`Warmup` (PDA): `{ start_slot, obs_count, cum_quote, ramp_q16, S_MIN, N_MIN, Q_MIN, warmup_done }`

* `S_MIN` — minimum slots since init (e.g., 2,000).
* `N_MIN` — minimum swaps observed (e.g., 64).
* `Q_MIN` — minimum cumulative absolute quote volume (e.g., 100 \* Q\_PIVOT).
* `ramp_q16` — ramp factor in Q0.16 fixed point ∈ \[0, 1].

### Bootstrap (at pool init)

1. Compute `P_floor = floor(R_* / S_circ)`; set `tick_floor = floor(log_γ(P_floor))` with γ=1.0001.
2. Set `tau = 0`.
3. Seed `twap_tick_seed = current_tick` and `twap_slot = current_slot`.
4. Define **bootstrap anchor** `R0 = max(twap_tick_seed, tick_floor + DELTA_BIAS)`.
5. Initialize `Warmup = { start_slot=slot, obs_count=0, cum_quote=0, ramp_q16=0, warmup_done=false }`.
6. PoMM: enable **lower band only** with a small per-tx `tau` budget; keep upper band disabled until warmup completes.

### Per-swap during warmup

* Update counters:

  * `obs_count += 1`
  * `cum_quote += abs(quote_filled)`
  * `slots_elapsed = slot - start_slot`
* Compute fractional progress (Q0.16):

  * `r_slots = min(1, slots_elapsed / S_MIN)`
  * `r_obs   = min(1, obs_count   / N_MIN)`
  * `r_vol   = min(1, cum_quote   / Q_MIN)`
  * `r = min(r_slots, r_obs, r_vol)`
  * `ramp_q16 = max(ramp_q16, r)`  // monotone non-decreasing
* **Anchors:**

  * If `r < 1`: use `R = R0` for work credit (ignore TWAP drift to avoid anchoring on noise).
  * If `r = 1` (all thresholds met): switch to `R = max(twap_tick, tick_floor + DELTA_BIAS)` and set `warmup_done = true`.
* **Fees:**

  * Execution surcharge `F_exec(x)` and slot penalty `P_slot` apply **at full strength from day 1** (stateless, robust).
  * Work credit is **ramped**: use `C_work_eff = (ramp_q16 * C_work) >> 16`.
  * Final fee: `φ = clamp(BASE + F_exec - C_work_eff + P_slot, MIN, MAX)`.
* **PoMM budget:**

  * While `warmup_done == false`, cap lower-band spend per tx and per slot (e.g., ≤ `Q_PIVOT`) and keep upper band off.

### Warmup exit

When `r = 1` (each threshold reached at least once):

* Freeze `ramp_q16 = 1`, set `warmup_done = true`.
* Enable PoMM upper band; lift per-tx PoMM budget to normal limits.
* From here, the controller and anchors operate as in Sections 3–5.

### Rationale & safety

* **No bad anchors:** Early trades can’t drag the reference; work credit uses fixed `R0` until enough time, trades, and volume accrue.
* **Always conservative:** Fees never drop below `MIN`; execution heat is charged immediately, deterring early violent moves.
* **Fully on-chain:** All thresholds are integers (slots, counts, volume). No external data, no identity.

### Reference snippet (per swap)

```
// counters
warm.obs_count += 1;
warm.cum_quote += q;
let slots = slot - warm.start_slot;
let r_slots = min_q16(slots, warm.S_MIN);
let r_obs   = min_q16(warm.obs_count, warm.N_MIN);
let r_vol   = min_q16(warm.cum_quote, warm.Q_MIN);
let r = min(r_slots, min(r_obs, r_vol));
warm.ramp_q16 = max(warm.ramp_q16, r);

// anchor
let R = if !warm.warmup_done { R0 } else { max(twap_tick, tick_floor + DELTA_BIAS) };

// fees
let c_work_eff = (warm.ramp_q16 * c_work) >> 16;
let phi_bps = clamp(BASE + f_exec + p_slot - c_work_eff, MIN, MAX);

// exit warmup
if !warm.warmup_done && r == ONE_Q16 {
    warm.warmup_done = true;
}
```
---

**Summary.** This spec preserves a hard, redeemable floor; channels dissipation into irreversible floor growth; and induces a gentle, configurable upward skew without oracles or complex state. The controller is transparent and integer‑friendly, and the PoMM is small enough to be mechanically safe while still materially helpful to range defense.
