
/// Feels Protocol - Concentrated Liquidity AMM
/// A next-generation automated market maker implementing concentrated liquidity positions
/// with advanced features like hooks, Token-2022 support, and oracle rate feeds.
/// Built on Solana for high-performance decentralized trading.
use anchor_lang::prelude::*;
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::token_2022::Token2022;
use anchor_spl::token_interface::{Mint, TokenAccount};

pub mod constant;
pub mod error;
pub mod instructions;
pub mod logic;
pub mod state;
pub mod utils;

// Re-export security macros for use in instructions
pub use utils::security;

// Import logic modules

// Import error types
pub use error::{FeelsError, FeelsProtocolError};

// Import all state types explicitly
use state::{
    // Core types
    MarketField,
    BufferAccount,
    ProtocolState,
    TickArray,
    TokenMetadata,
    token::FeelsSOL,
    // Position types
    TickPositionMetadata,
    // Market data
    MarketDataSource,
    TwapOracle,
    // Tick management
    TickArrayRouter,
    MarketManager,
};

// Re-export instruction types for SDK
pub use instructions::{
    OrderParams, 
    OrderResult, 
    OrderType, 
    RateParams,
    InitializeMarketParams,
    InitializeMarketResult,
    MarketOperation,
    MarketConfigParams,
    FieldCommitmentUpdate,
    PoolUpdateParams,
    InitializeKeeperRegistry,
    AddKeeper,
    RemoveKeeper,
    AddKeeperParams,
    RemoveKeeperParams,
    InitializePoolStatus,
    EnforceFees,
    EnforceFeesParams,
    EnforceFeesResult,
    TokenCreateParams,
    TokenCreateResult,
    CreateToken,
    CleanupTickArrayParams,
    CleanupTickArrayResult,
};

// Re-export Duration from state
pub use state::duration::Duration;

// Import instruction contexts

// Client account modules will be auto-generated by Anchor
// Temporarily removed to test #[program] macro compilation

// Import instruction modules are handled individually within the program macro

declare_id!("Fee1sProtoco11111111111111111111111111111111");

// Legacy protocol initialization contexts - may need updating to work with market physics
#[derive(Accounts)]
pub struct InitializeFeels<'info> {
    /// Protocol state account
    #[account(
        init,
        payer = authority,
        space = ProtocolState::SIZE,
        seeds = [b"protocol"],
        bump
    )]
    pub protocol_state: Account<'info, ProtocolState>,

    /// Protocol authority and payer
    #[account(mut)]
    pub authority: Signer<'info>,

    /// Protocol treasury account
    /// CHECK: Can be any account that will receive fees
    pub treasury: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct InitializeFeelsSOL<'info> {
    /// FeelsSOL wrapper account
    #[account(
        init,
        payer = authority,
        space = FeelsSOL::SIZE,
        seeds = [b"feelssol"],
        bump
    )]
    pub feelssol: Account<'info, FeelsSOL>,

    /// FeelsSOL Token-2022 mint
    #[account(
        init,
        payer = authority,
        mint::decimals = 9,
        mint::authority = feelssol,
        mint::freeze_authority = feelssol,
    )]
    pub feels_mint: InterfaceAccount<'info, Mint>,
    
    /// Underlying token mint
    pub underlying_mint: InterfaceAccount<'info, Mint>,
    
    /// Vault to hold underlying tokens
    #[account(
        init,
        payer = authority,
        token::mint = underlying_mint,
        token::authority = feelssol,
        seeds = [b"feelssol_vault", underlying_mint.key().as_ref()],
        bump
    )]
    pub vault: InterfaceAccount<'info, TokenAccount>,

    /// Protocol authority
    #[account(mut)]
    pub authority: Signer<'info>,

    pub token_program: Program<'info, Token2022>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}


#[derive(Accounts)]
pub struct InitializeMarket<'info> {
    /// Market field account storing the physics state
    #[account(
        init,
        payer = authority,
        space = MarketField::SIZE,
        seeds = [
            b"market",
            token_0_mint.key().as_ref(),
            token_1_mint.key().as_ref(),
        ],
        bump
    )]
    pub market_field: Account<'info, MarketField>,

    /// Buffer account for fee collection and rebates
    #[account(
        init,
        payer = authority,
        space = BufferAccount::SIZE,
        seeds = [
            b"buffer",
            market_field.key().as_ref(),
        ],
        bump
    )]
    pub buffer_account: Account<'info, BufferAccount>,

    /// Token 0 mint (order doesn't matter - will be canonicalized)
    pub token_0_mint: InterfaceAccount<'info, Mint>,

    /// Token 1 mint (order doesn't matter - will be canonicalized)
    pub token_1_mint: InterfaceAccount<'info, Mint>,

    /// FeelsSOL wrapper account for validation
    #[account(
        seeds = [b"feelssol"],
        bump,
        constraint = feelssol.feels_mint == token_0_mint.key() || feelssol.feels_mint == token_1_mint.key() @ FeelsProtocolError::InvalidPool
    )]
    pub feelssol: Account<'info, FeelsSOL>,

    /// Token 0 vault
    #[account(
        init,
        payer = authority,
        token::mint = token_0_mint,
        token::authority = market_field,
        seeds = [
            b"vault",
            market_field.key().as_ref(),
            token_0_mint.key().as_ref(),
        ],
        bump
    )]
    pub token_0_vault: InterfaceAccount<'info, TokenAccount>,

    /// Token 1 vault
    #[account(
        init,
        payer = authority,
        token::mint = token_1_mint,
        token::authority = market_field,
        seeds = [
            b"vault",
            market_field.key().as_ref(),
            token_1_mint.key().as_ref(),
        ],
        bump
    )]
    pub token_1_vault: InterfaceAccount<'info, TokenAccount>,

    /// TWAP oracle for price tracking
    #[account(
        init,
        payer = authority,
        space = 8 + std::mem::size_of::<TwapOracle>(),
        seeds = [b"twap", market_field.key().as_ref()],
        bump
    )]
    pub twap_oracle: AccountLoader<'info, TwapOracle>,

    /// Market data source for field updates
    #[account(
        init,
        payer = authority,
        space = 8 + std::mem::size_of::<MarketDataSource>(),
        seeds = [b"data_source", market_field.key().as_ref()],
        bump
    )]
    pub market_data_source: AccountLoader<'info, MarketDataSource>,

    /// Protocol state for validation
    #[account(
        seeds = [b"protocol"],
        bump
    )]
    pub protocol_state: Account<'info, ProtocolState>,

    /// Market authority and payer
    #[account(mut)]
    pub authority: Signer<'info>,

    /// Required programs
    pub token_program: Program<'info, Token2022>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}

// Hook management removed - hooks are now managed at the protocol level, not per-market

/// Market configuration context
#[derive(Accounts)]
pub struct ConfigureMarket<'info> {
    /// Market field to configure
    #[account(mut)]
    pub market_field: Account<'info, MarketField>,
    
    /// Buffer account (optional, for rebate configuration)
    #[account(
        mut,
        seeds = [b"buffer", market_field.key().as_ref()],
        bump,
    )]
    pub buffer_account: Option<Account<'info, BufferAccount>>,
    
    /// Authority (must be market authority)
    pub authority: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

// ============================================================================
// 3D Order System Contexts
// ============================================================================

/// Context for executing orders through the physics engine
#[derive(Accounts)]
pub struct Order<'info> {
    /// Market field account containing physics state
    #[account(mut)]
    pub market_field: Account<'info, MarketField>,
    
    /// Market manager for AMM operations
    #[account(
        mut,
        seeds = [b"manager", market_field.key().as_ref()],
        bump
    )]
    pub market_manager: AccountLoader<'info, MarketManager>,
    
    /// Buffer account for fees and rebates
    #[account(
        mut,
        seeds = [b"buffer", market_field.key().as_ref()],
        bump
    )]
    pub buffer_account: Account<'info, BufferAccount>,
    
    /// User executing the order
    #[account(mut)]
    pub user: Signer<'info>,
    
    /// User's token 0 account
    #[account(mut)]
    pub user_token_0: InterfaceAccount<'info, TokenAccount>,
    
    /// User's token 1 account
    #[account(mut)]
    pub user_token_1: InterfaceAccount<'info, TokenAccount>,
    
    /// Market's token 0 vault
    #[account(
        mut,
        seeds = [b"vault", market_field.key().as_ref(), user_token_0.mint.as_ref()],
        bump
    )]
    pub market_token_0: InterfaceAccount<'info, TokenAccount>,
    
    /// Market's token 1 vault
    #[account(
        mut,
        seeds = [b"vault", market_field.key().as_ref(), user_token_1.mint.as_ref()],
        bump
    )]
    pub market_token_1: InterfaceAccount<'info, TokenAccount>,
    
    /// Token program
    pub token_program: Program<'info, Token2022>,
    
    /// System program
    pub system_program: Program<'info, System>,
    
    // Optional accounts for advanced features
    /// Tick array router for efficient tick access
    #[account(
        seeds = [b"router", market_field.key().as_ref()],
        bump,
    )]
    pub tick_array_router: Option<Account<'info, TickArrayRouter>>,
}


/// Context for modifying positions (liquidity orders)
#[derive(Accounts)]
pub struct OrderModify<'info> {
    /// Market field account
    #[account(mut)]
    pub market_field: Account<'info, MarketField>,
    
    /// Market manager for AMM operations
    #[account(
        mut,
        seeds = [b"manager", market_field.key().as_ref()],
        bump
    )]
    pub market_manager: AccountLoader<'info, MarketManager>,
    
    /// Buffer account
    #[account(
        mut,
        seeds = [b"buffer", market_field.key().as_ref()],
        bump
    )]
    pub buffer_account: Account<'info, BufferAccount>,
    
    /// Position/Order owner
    pub owner: Signer<'info>,
    
    /// Position metadata (for liquidity orders)
    #[account(
        mut,
        constraint = position.market == market_field.key() @ FeelsProtocolError::InvalidMarket,
        constraint = position.owner == owner.key() @ FeelsProtocolError::InvalidOwner,
    )]
    pub position: Account<'info, TickPositionMetadata>,
    
    /// Optional: User token accounts for adjustments
    pub user_token_0: Option<InterfaceAccount<'info, TokenAccount>>,
    pub user_token_1: Option<InterfaceAccount<'info, TokenAccount>>,
    
    /// Market vaults
    #[account(mut)]
    pub market_token_0: InterfaceAccount<'info, TokenAccount>,
    #[account(mut)]
    pub market_token_1: InterfaceAccount<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token2022>,
}

// Redenomination removed - handled through market physics rebasing


#[derive(Accounts)]
pub struct CleanupEmptyTickArray<'info> {
    #[account(mut)]
    pub market_field: Account<'info, MarketField>,

    #[account(
        mut,
        close = beneficiary
    )]
    pub tick_array: AccountLoader<'info, TickArray>,

    /// Anyone can be the beneficiary (incentivizes cleanup)
    #[account(mut)]
    pub beneficiary: Signer<'info>,
}

#[derive(Accounts)]
pub struct CleanupTickArrayV2<'info> {
    #[account(mut)]
    pub market_field: Account<'info, MarketField>,
    
    /// Market manager for bitmap updates
    #[account(
        mut,
        seeds = [b"manager", market_field.key().as_ref()],
        bump
    )]
    pub market_manager: AccountLoader<'info, MarketManager>,

    /// The tick array to cleanup (will be closed)
    /// CHECK: Validated in handler
    #[account(
        mut,
        close = cleaner,
        constraint = tick_array.to_account_info().owner == __program_id @ FeelsProtocolError::InvalidAccountOwner
    )]
    pub tick_array: AccountLoader<'info, TickArray>,

    /// The cleaner who initiated the cleanup
    #[account(mut)]
    pub cleaner: Signer<'info>,

    /// Protocol treasury (required for incentivized mode)
    /// CHECK: Only needed for incentivized cleanup
    pub protocol_fee_recipient: Option<UncheckedAccount<'info>>,

    pub system_program: Program<'info, System>,
}

// ========================================================================
// Phase 2 Account Structs
// ========================================================================



// ExecuteRedenomination removed - use redenominate instruction with unified order system




// Feels Protocol - Unified 3D Order System
// 
// All trading and liquidity operations are unified under a single 3D order model
// that combines rate, duration, and leverage dimensions. This ensures consistent
// execution paths for fees, hooks, and risk management.
// 
// # Core Trading Instructions
// 
// - `order`: Universal entry point for ALL trading operations
//   - OrderType::Immediate for swaps (spot and leveraged)
//   - OrderType::Liquidity for adding/removing liquidity  
//   - OrderType::Limit for limit orders
// 
// - `order_compute`: Pre-compute required accounts for complex orders
// - `order_modify`: Modify existing orders (leverage, duration, etc.)
// - `redenominate`: Handle leveraged position redenomination
// 
// # Why Unified?
// 
// The unified order system ensures:
// 1. Consistent fee calculation across all operations
// 2. Proper hook execution for all trade types
// 3. Unified risk management and leverage handling
// 4. Simplified client integration
// 5. Better composability for complex operations
// Temporarily simplify #[program] module to isolate issue
#[program]
pub mod feels {
    use super::*;

    /// Initialize the protocol state
    pub fn initialize_feels(
        ctx: Context<InitializeFeels>,
        treasury: Pubkey,
        fee_rate: u16,
    ) -> Result<()> {
        // Initialize protocol state
        let protocol_state = &mut ctx.accounts.protocol_state;
        protocol_state.is_initialized = true;
        protocol_state.authority = ctx.accounts.authority.key();
        protocol_state.treasury = treasury;
        protocol_state.default_protocol_fee_rate = fee_rate;
        protocol_state.max_pool_fee_rate = 1000; // 10%
        protocol_state.paused = false;
        protocol_state.pool_creation_allowed = true;
        protocol_state.total_pools = 0;
        protocol_state.total_fees_collected = 0;
        protocol_state.total_volume_usd = 0;
        protocol_state.total_fees_collected_usd = 0;
        protocol_state.total_liquidity_usd = 0;
        protocol_state.initialized_at = Clock::get()?.unix_timestamp;
        
        Ok(())
    }

    /// Unified order handler for ALL trading operations
    /// This is the single entry point for swaps, position transitions, liquidity, and limit orders
    pub fn order<'info>(
        ctx: Context<'_, '_, 'info, 'info, Order<'info>>,
        params: crate::instructions::OrderParams,
    ) -> Result<crate::instructions::OrderResult> {
        crate::instructions::order_handler(ctx, params)
    }

    /// Initialize FeelsSOL wrapper token
    pub fn initialize_feelssol(
        ctx: Context<InitializeFeelsSOL>,
        _decimals: u8,
    ) -> Result<()> {
        // Initialize FeelsSOL account
        let feelssol = &mut ctx.accounts.feelssol;
        feelssol.feels_mint = ctx.accounts.feels_mint.key();
        feelssol.underlying_mint = ctx.accounts.underlying_mint.key();
        feelssol.vault = ctx.accounts.vault.key();
        feelssol.authority = ctx.accounts.authority.key();
        feelssol.exchange_rate = 1_000_000_000; // 1:1 initial exchange rate
        feelssol.total_supply = 0;
        feelssol.total_underlying = 0;
        feelssol.last_yield_update = Clock::get()?.unix_timestamp;
        feelssol.cumulative_yield = 0;
        feelssol.yield_rate_per_second = 0;
        feelssol.is_paused = false;
        feelssol.deposits_paused = false;
        feelssol.withdrawals_paused = false;
        feelssol.created_at = Clock::get()?.unix_timestamp;
        feelssol.last_updated_at = Clock::get()?.unix_timestamp;
        feelssol._reserved = [0; 64];
        
        Ok(())
    }


    /// Initialize a new market with market field and buffer accounts
    pub fn initialize_market<'info>(
        ctx: Context<'_, '_, 'info, 'info, InitializeMarket<'info>>,
        params: InitializeMarketParams,
    ) -> Result<InitializeMarketResult> {
        crate::instructions::market_initialize::initialize_market(ctx, params)
    }
    
    /// Initialize the keeper registry
    pub fn initialize_keeper_registry(
        ctx: Context<InitializeKeeperRegistry>
    ) -> Result<()> {
        crate::instructions::keeper_registry::initialize_keeper_registry(ctx)
    }
    
    /// Add a keeper to the registry
    pub fn add_keeper(
        ctx: Context<AddKeeper>,
        params: AddKeeperParams,
    ) -> Result<()> {
        crate::instructions::keeper_registry::add_keeper(ctx, params)
    }
    
    /// Remove a keeper from the registry
    pub fn remove_keeper(
        ctx: Context<RemoveKeeper>,
        params: RemoveKeeperParams,
    ) -> Result<()> {
        crate::instructions::keeper_registry::remove_keeper(ctx, params)
    }
    
    // Temporarily commented to fix build issues
    // TODO: Re-enable these once we fix the import issues
    
    /*
    
    /// Initialize pool status for fee enforcement
    pub fn initialize_pool_status(
        ctx: Context<InitializePoolStatus>,
    ) -> Result<()> {
        enforce_fees::initialize_pool_status(ctx)
    }
    
    /// Enforce fee policy on pools
    pub fn enforce_fees<'info>(
        ctx: Context<'_, '_, 'info, 'info, EnforceFees<'info>>,
        params: EnforceFeesParams,
    ) -> Result<EnforceFeesResult> {
        enforce_fees::handler(ctx, params)
    }
    
    /// Update market configuration
    pub fn update_market<'info>(
        ctx: Context<'_, '_, 'info, 'info, market_update::MarketUpdate<'info>>,
        operation: MarketOperation,
    ) -> Result<()> {
        market_update::handler(ctx, operation)
    }
    
    /// Create a new token
    pub fn create_token<'info>(
        ctx: Context<'_, '_, 'info, 'info, CreateToken<'info>>,
        params: TokenCreateParams,
    ) -> Result<TokenCreateResult> {
        token::handler(ctx, params)
    }
    
    /// Cleanup tick array
    pub fn cleanup_tick_array(
        ctx: Context<cleanup::CleanupTickArray>,
        params: cleanup::CleanupTickArrayParams,
    ) -> Result<cleanup::CleanupTickArrayResult> {
        cleanup::cleanup_tick_array(ctx, params)
    }
    */
}
