
//! # Feels Protocol - 3D Thermodynamic AMM
//! 
//! Unified AMM implementing thermodynamic market physics across three dimensions:
//! - **Spot (S)**: Token exchange
//! - **Time (T)**: Duration/lending markets  
//! - **Leverage (L)**: Risk-scaled positions
//! 
//! Core mechanics:
//! - Market state: P = (S,T,L) with potential V(P) = -Σ ŵᵢ ln(i)
//! - Work-based fees: W = V(P₂) - V(P₁) 
//! - Hub architecture: All pairs include FeelsSOL for 2-hop routing
//! - Conservation law: Σ wᵢ ln(gᵢ) = 0
use anchor_lang::prelude::*;
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::token_2022::Token2022;
use anchor_spl::token_interface::{Mint, TokenAccount};

pub mod error;
pub mod instructions;
pub mod logic;
pub mod state;
pub mod utils;

// Re-export security macros for use in instructions
pub use utils::security;

// Import logic modules

// Import error types
pub use error::{FeelsError, FeelsProtocolError};

// Import all state types explicitly
use state::{
    // Core types
    Market, // Unified market account
    BufferAccount,
    ProtocolState,
    TickArray,
    TokenMetadata,
    token::FeelsSOL,
    // Position types
    TickPositionMetadata,
    // Market data
    MarketDataSource,
    TwapOracle,
    // Tick management
    TickArrayRouter,
};

// Re-export instruction types for SDK
pub use instructions::{
    OrderParams, 
    OrderResult, 
    OrderType, 
    RateParams,
    InitializeMarketParams,
    InitializeMarketResult,
    MarketOperation,
    MarketConfigParams,
    FieldCommitmentUpdate,
    PoolUpdateParams,
    InitializeKeeperRegistry,
    AddKeeper,
    RemoveKeeper,
    AddKeeperParams,
    RemoveKeeperParams,
    InitializePoolStatus,
    EnforceFees,
    EnforceFeesParams,
    EnforceFeesResult,
    TokenCreateParams,
    TokenCreateResult,
    CreateToken,
    CleanupTickArrayParams,
    CleanupTickArrayResult,
    // Entry/Exit types
    EnterProtocol,
    ExitProtocol,
    EnterProtocolParams,
    ExitProtocolParams,
    EntryExitResult,
    // Position flow types
    EnterPosition,
    ExitPosition,
    EnterPositionParams,
    ExitPositionParams,
    PositionFlowResult,
};

// Re-export Duration from state
pub use state::duration::Duration;

// Import instruction contexts

// Client account modules will be auto-generated by Anchor
// Temporarily removed to test #[program] macro compilation

// Import instruction modules are handled individually within the program macro

declare_id!("Fee1sProtoco11111111111111111111111111111111");

// Protocol initialization contexts
#[derive(Accounts)]
pub struct InitializeFeels<'info> {
    /// Protocol state account
    #[account(
        init,
        payer = authority,
        space = ProtocolState::SIZE,
        seeds = [b"protocol"],
        bump
    )]
    pub protocol_state: Account<'info, ProtocolState>,

    /// Protocol authority and payer
    #[account(mut)]
    pub authority: Signer<'info>,

    /// Protocol treasury account
    /// CHECK: Can be any account that will receive fees
    pub treasury: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct InitializeFeelsSOL<'info> {
    /// FeelsSOL wrapper account
    #[account(
        init,
        payer = authority,
        space = FeelsSOL::SIZE,
        seeds = [b"feelssol"],
        bump
    )]
    pub feelssol: Account<'info, FeelsSOL>,

    /// FeelsSOL Token-2022 mint
    #[account(
        init,
        payer = authority,
        mint::decimals = 9,
        mint::authority = feelssol,
        mint::freeze_authority = feelssol,
    )]
    pub feels_mint: InterfaceAccount<'info, Mint>,
    
    /// Underlying token mint
    pub underlying_mint: InterfaceAccount<'info, Mint>,
    
    /// Vault to hold underlying tokens
    #[account(
        init,
        payer = authority,
        token::mint = underlying_mint,
        token::authority = feelssol,
        seeds = [b"feelssol_vault", underlying_mint.key().as_ref()],
        bump
    )]
    pub vault: InterfaceAccount<'info, TokenAccount>,

    /// Protocol authority
    #[account(mut)]
    pub authority: Signer<'info>,

    pub token_program: Program<'info, Token2022>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}


#[derive(Accounts)]
pub struct InitializeMarket<'info> {
    /// Unified market account storing all state
    #[account(
        init,
        payer = authority,
        space = Market::LEN,
        seeds = [
            b"market",
            token_0_mint.key().as_ref(),
            token_1_mint.key().as_ref(),
        ],
        bump
    )]
    pub market: Account<'info, Market>,

    /// Buffer account for fee collection and rebates
    #[account(
        init,
        payer = authority,
        space = BufferAccount::LEN,
        seeds = [
            b"buffer",
            market.key().as_ref(),
        ],
        bump
    )]
    pub buffer_account: Account<'info, BufferAccount>,

    /// Token 0 mint (order doesn't matter - will be canonicalized)
    pub token_0_mint: InterfaceAccount<'info, Mint>,

    /// Token 1 mint (order doesn't matter - will be canonicalized)
    pub token_1_mint: InterfaceAccount<'info, Mint>,

    /// FeelsSOL wrapper account for validation
    #[account(
        seeds = [b"feelssol"],
        bump,
        constraint = feelssol.feels_mint == token_0_mint.key() || feelssol.feels_mint == token_1_mint.key() @ FeelsProtocolError::InvalidPool
    )]
    pub feelssol: Account<'info, FeelsSOL>,

    /// Token 0 vault
    #[account(
        init,
        payer = authority,
        token::mint = token_0_mint,
        token::authority = market,
        seeds = [
            b"vault",
            market.key().as_ref(),
            token_0_mint.key().as_ref(),
        ],
        bump
    )]
    pub token_0_vault: InterfaceAccount<'info, TokenAccount>,

    /// Token 1 vault
    #[account(
        init,
        payer = authority,
        token::mint = token_1_mint,
        token::authority = market,
        seeds = [
            b"vault",
            market.key().as_ref(),
            token_1_mint.key().as_ref(),
        ],
        bump
    )]
    pub token_1_vault: InterfaceAccount<'info, TokenAccount>,

    /// TWAP oracle for price tracking
    #[account(
        init,
        payer = authority,
        space = 8 + std::mem::size_of::<TwapOracle>(),
        seeds = [b"twap", market.key().as_ref()],
        bump
    )]
    pub twap_oracle: AccountLoader<'info, TwapOracle>,

    /// Market data source for field updates
    #[account(
        init,
        payer = authority,
        space = 8 + std::mem::size_of::<MarketDataSource>(),
        seeds = [b"data_source", market.key().as_ref()],
        bump
    )]
    pub market_data_source: AccountLoader<'info, MarketDataSource>,

    /// Protocol state for validation
    #[account(
        seeds = [b"protocol"],
        bump
    )]
    pub protocol_state: Account<'info, ProtocolState>,

    /// Market authority and payer
    #[account(mut)]
    pub authority: Signer<'info>,

    /// Required programs
    pub token_program: Program<'info, Token2022>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}

// Hook management removed - hooks are now managed at the protocol level, not per-market

/// Market configuration context
#[derive(Accounts)]
pub struct ConfigureMarket<'info> {
    /// Market to configure
    #[account(mut)]
    pub market: Account<'info, Market>,
    
    /// Buffer account (optional, for rebate configuration)
    #[account(
        mut,
        seeds = [b"buffer", market.key().as_ref()],
        bump,
    )]
    pub buffer_account: Option<Account<'info, BufferAccount>>,
    
    /// Authority (must be market authority)
    pub authority: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

// ============================================================================
// 3D Order System Contexts
// ============================================================================

/// Context for executing orders through the physics engine
#[derive(Accounts)]
pub struct Order<'info> {
    /// Unified market account
    #[account(mut)]
    pub market: Account<'info, Market>,
    
    /// Buffer account for fees and rebates
    #[account(
        mut,
        seeds = [b"buffer", market.key().as_ref()],
        bump
    )]
    pub buffer_account: Account<'info, BufferAccount>,
    
    /// User executing the order
    #[account(mut)]
    pub user: Signer<'info>,
    
    /// User's token 0 account
    #[account(mut)]
    pub user_token_0: InterfaceAccount<'info, TokenAccount>,
    
    /// User's token 1 account
    #[account(mut)]
    pub user_token_1: InterfaceAccount<'info, TokenAccount>,
    
    /// Market's token 0 vault
    #[account(
        mut,
        seeds = [b"vault", market.key().as_ref(), user_token_0.mint.as_ref()],
        bump
    )]
    pub market_token_0: InterfaceAccount<'info, TokenAccount>,
    
    /// Market's token 1 vault
    #[account(
        mut,
        seeds = [b"vault", market.key().as_ref(), user_token_1.mint.as_ref()],
        bump
    )]
    pub market_token_1: InterfaceAccount<'info, TokenAccount>,
    
    /// Token program
    pub token_program: Program<'info, Token2022>,
    
    /// System program
    pub system_program: Program<'info, System>,
    
    // Optional accounts for advanced features
    /// Tick array router for efficient tick access
    #[account(
        seeds = [b"router", market.key().as_ref()],
        bump,
    )]
    pub tick_array_router: Option<Account<'info, TickArrayRouter>>,
}


/// Context for modifying positions (liquidity orders)
#[derive(Accounts)]
pub struct OrderModify<'info> {
    /// Unified market account
    #[account(mut)]
    pub market: Account<'info, Market>,
    
    /// Buffer account
    #[account(
        mut,
        seeds = [b"buffer", market.key().as_ref()],
        bump
    )]
    pub buffer_account: Account<'info, BufferAccount>,
    
    /// Position/Order owner
    pub owner: Signer<'info>,
    
    /// Position metadata (for liquidity orders)
    #[account(
        mut,
        constraint = position.market == market.key() @ FeelsProtocolError::InvalidMarket,
        constraint = position.owner == owner.key() @ FeelsProtocolError::InvalidOwner,
    )]
    pub position: Account<'info, TickPositionMetadata>,
    
    /// Optional: User token accounts for adjustments
    pub user_token_0: Option<InterfaceAccount<'info, TokenAccount>>,
    pub user_token_1: Option<InterfaceAccount<'info, TokenAccount>>,
    
    /// Market vaults
    #[account(mut)]
    pub market_token_0: InterfaceAccount<'info, TokenAccount>,
    #[account(mut)]
    pub market_token_1: InterfaceAccount<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token2022>,
}

// Redenomination removed - handled through market physics rebasing


#[derive(Accounts)]
pub struct CleanupEmptyTickArray<'info> {
    #[account(mut)]
    pub market: Account<'info, Market>,

    #[account(
        mut,
        close = beneficiary
    )]
    pub tick_array: AccountLoader<'info, TickArray>,

    /// Anyone can be the beneficiary (incentivizes cleanup)
    #[account(mut)]
    pub beneficiary: Signer<'info>,
}

#[derive(Accounts)]
pub struct CleanupTickArrayV2<'info> {
    #[account(mut)]
    pub market: Account<'info, Market>,

    /// The tick array to cleanup (will be closed)
    /// CHECK: Validated in handler
    #[account(
        mut,
        close = cleaner,
        constraint = tick_array.to_account_info().owner == __program_id @ FeelsProtocolError::InvalidAccountOwner
    )]
    pub tick_array: AccountLoader<'info, TickArray>,

    /// The cleaner who initiated the cleanup
    #[account(mut)]
    pub cleaner: Signer<'info>,

    /// Protocol treasury (required for incentivized mode)
    /// CHECK: Only needed for incentivized cleanup
    pub protocol_fee_recipient: Option<UncheckedAccount<'info>>,

    pub system_program: Program<'info, System>,
}

// ========================================================================
// Phase 2 Account Structs
// ========================================================================



// ExecuteRedenomination removed - use redenominate instruction with unified order system




// Unified 3D order system handles all operations through single entry point
#[program]
pub mod feels {
    use super::*;

    /// Initialize protocol with global parameters and treasury
    pub fn initialize_feels(
        ctx: Context<InitializeFeels>,
        treasury: Pubkey,
        fee_rate: u16,
    ) -> Result<()> {
        // Initialize protocol state
        let protocol_state = &mut ctx.accounts.protocol_state;
        protocol_state.is_initialized = true;
        protocol_state.authority = ctx.accounts.authority.key();
        protocol_state.treasury = treasury;
        protocol_state.default_protocol_fee_rate = fee_rate;
        protocol_state.max_pool_fee_rate = 1000; // 10%
        protocol_state.paused = false;
        protocol_state.pool_creation_allowed = true;
        protocol_state.total_pools = 0;
        protocol_state.total_fees_collected = 0;
        protocol_state.total_volume_usd = 0;
        protocol_state.total_fees_collected_usd = 0;
        protocol_state.total_liquidity_usd = 0;
        protocol_state.initialized_at = Clock::get()?.unix_timestamp;
        
        Ok(())
    }

    /// Order handler for all market operations.
    /// Calculates thermodynamic work W = V(P₂) - V(P₁) for fees/rebates
    pub fn order<'info>(
        ctx: Context<'_, '_, 'info, 'info, Order<'info>>,
        params: crate::instructions::OrderParams,
    ) -> Result<crate::instructions::OrderResult> {
        crate::instructions::order_handler(ctx, params)
    }

    /// Enter protocol by converting JitoSOL to FeelsSOL.
    /// Validates single-hop entry flow and applies work-based fees.
    pub fn enter_protocol(
        ctx: Context<crate::instructions::EnterProtocol>,
        params: crate::instructions::EnterProtocolParams,
    ) -> Result<crate::instructions::EntryExitResult> {
        crate::instructions::enter_protocol_handler(ctx, params)
    }

    /// Exit protocol by converting FeelsSOL to JitoSOL.
    /// Validates single-hop exit flow and applies work-based fees.
    pub fn exit_protocol(
        ctx: Context<crate::instructions::ExitProtocol>,
        params: crate::instructions::ExitProtocolParams,
    ) -> Result<crate::instructions::EntryExitResult> {
        crate::instructions::exit_protocol_handler(ctx, params)
    }

    /// Enter a position by converting FeelsSOL to position tokens.
    /// Mints position tokens and transfers FeelsSOL to vault.
    pub fn enter_position(
        ctx: Context<crate::instructions::EnterPosition>,
        params: crate::instructions::EnterPositionParams,
    ) -> Result<crate::instructions::PositionFlowResult> {
        crate::instructions::enter_position_handler(ctx, params)
    }

    /// Exit a position by converting position tokens to FeelsSOL.
    /// Burns position tokens and transfers FeelsSOL from vault.
    pub fn exit_position(
        ctx: Context<crate::instructions::ExitPosition>,
        params: crate::instructions::ExitPositionParams,
    ) -> Result<crate::instructions::PositionFlowResult> {
        crate::instructions::exit_position_handler(ctx, params)
    }

    /// Initialize FeelsSOL hub token for universal routing
    pub fn initialize_feelssol(
        ctx: Context<InitializeFeelsSOL>,
        _decimals: u8,
    ) -> Result<()> {
        // Initialize FeelsSOL account
        let feelssol = &mut ctx.accounts.feelssol;
        feelssol.feels_mint = ctx.accounts.feels_mint.key();
        feelssol.underlying_mint = ctx.accounts.underlying_mint.key();
        feelssol.vault = ctx.accounts.vault.key();
        feelssol.authority = ctx.accounts.authority.key();
        feelssol.exchange_rate = 1_000_000_000; // 1:1 initial exchange rate
        feelssol.total_supply = 0;
        feelssol.total_underlying = 0;
        feelssol.last_yield_update = Clock::get()?.unix_timestamp;
        feelssol.cumulative_yield = 0;
        feelssol.yield_rate_per_second = 0;
        feelssol.is_paused = false;
        feelssol.deposits_paused = false;
        feelssol.withdrawals_paused = false;
        feelssol.created_at = Clock::get()?.unix_timestamp;
        feelssol.last_updated_at = Clock::get()?.unix_timestamp;
        feelssol._reserved = [0; 64];
        
        Ok(())
    }


    /// Initialize market with (S,T,L) state, buffer, and oracles.
    /// Requires one token to be FeelsSOL
    pub fn initialize_market<'info>(
        ctx: Context<'_, '_, 'info, 'info, InitializeMarket<'info>>,
        params: InitializeMarketParams,
    ) -> Result<()> {
        crate::instructions::initialize_market(ctx, params)
    }
    
    /// Initialize the keeper registry
    pub fn initialize_keeper_registry(
        ctx: Context<InitializeKeeperRegistry>
    ) -> Result<()> {
        crate::instructions::keeper_registry::initialize_keeper_registry(ctx)
    }
    
    /// Add a keeper to the registry
    pub fn add_keeper(
        ctx: Context<AddKeeper>,
        params: AddKeeperParams,
    ) -> Result<()> {
        crate::instructions::keeper_registry::add_keeper(ctx, params)
    }
    
    /// Remove a keeper from the registry
    pub fn remove_keeper(
        ctx: Context<RemoveKeeper>,
        params: RemoveKeeperParams,
    ) -> Result<()> {
        crate::instructions::keeper_registry::remove_keeper(ctx, params)
    }
    
    // Temporarily commented to fix build issues
    // TODO: Re-enable these once we fix the import issues
    
    /*
    
    /// Initialize pool status for fee enforcement
    pub fn initialize_pool_status(
        ctx: Context<InitializePoolStatus>,
    ) -> Result<()> {
        enforce_fees::initialize_pool_status(ctx)
    }
    
    /// Enforce fee policy on pools
    pub fn enforce_fees<'info>(
        ctx: Context<'_, '_, 'info, 'info, EnforceFees<'info>>,
        params: EnforceFeesParams,
    ) -> Result<EnforceFeesResult> {
        enforce_fees::handler(ctx, params)
    }
    
    /// Update market configuration
    pub fn update_market<'info>(
        ctx: Context<'_, '_, 'info, 'info, market_update::MarketUpdate<'info>>,
        operation: MarketOperation,
    ) -> Result<()> {
        market_update::handler(ctx, operation)
    }
    
    /// Create a new token
    pub fn create_token<'info>(
        ctx: Context<'_, '_, 'info, 'info, CreateToken<'info>>,
        params: TokenCreateParams,
    ) -> Result<TokenCreateResult> {
        token::handler(ctx, params)
    }
    
    /// Cleanup tick array
    pub fn cleanup_tick_array(
        ctx: Context<cleanup::CleanupTickArray>,
        params: cleanup::CleanupTickArrayParams,
    ) -> Result<cleanup::CleanupTickArrayResult> {
        cleanup::cleanup_tick_array(ctx, params)
    }
    */
}
